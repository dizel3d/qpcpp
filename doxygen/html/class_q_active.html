<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: QActive Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>QActive Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="QActive" -->
<p>Base class for derivation of application-level active object classes.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qf_8h_source.html">qf.h</a>&gt;</code></p>

<p><a href="class_q_active-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336">start</a> (<a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> prio, <a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> qLen, void *stkSto, <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> stkSize, <a class="el" href="struct_q_event.html">QEvent</a> const *ie=(<a class="el" href="struct_q_event.html">QEvent</a> *) 0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts execution of an active object and registers the object with the framework.  <a href="#aedb01d8ba6b6de77c8b72df057abe336"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a">postFIFO</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an event <em>e</em> directly to the event queue of the acitve object <em>me</em> using the First-In-First-Out (FIFO) policy.  <a href="#a46f02154787a4f0f0ac91638251da82a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a6c2deb168c17567ab6bbc2178d67878d">postLIFO</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an event directly to the event queue of the active object <em>me</em> using the Last-In-First-Out (LIFO) policy.  <a href="#a6c2deb168c17567ab6bbc2178d67878d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a0cea14cd2b9f2f2b5a8185625eed99d0">run</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Traditional loop-structured thread routine for an active object.  <a href="#a0cea14cd2b9f2f2b5a8185625eed99d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a29d494a0802145fdaf510ccc89c61dce">get_</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an event from the event queue of an active object.  <a href="#a29d494a0802145fdaf510ccc89c61dce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a36aa82f457ec53ab04b3f6b69a67f72c">unsubscribeAll</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of all signals to the active object.  <a href="#a36aa82f457ec53ab04b3f6b69a67f72c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a70d9ff3bd1838921d2d25223900e0ca8">m_prio</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_q_f.html" title="QF services.">QF</a> priority associated with the active object.  <a href="#a70d9ff3bd1838921d2d25223900e0ca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a39ad6e0e372e7e1734867e8e6b22ddcc">m_running</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Boolean loop variable determining if the thread routine of the active object is running.  <a href="#a39ad6e0e372e7e1734867e8e6b22ddcc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#ad6830d1617b22f521d06e3e6c184519e">QActive</a> (QF_ACTIVE_STATE_ initial)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">protected constructor  <a href="#ad6830d1617b22f521d06e3e6c184519e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#ad2001894b640ac76f5779f6beb87b694">stop</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops execution of an active object and removes it from the framework's supervision.  <a href="#ad2001894b640ac76f5779f6beb87b694"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#aa2145cfedf8c4616dacdbf0b7609d8f2">subscribe</a> (<a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes for delivery of signal <em>sig</em> to the active object.  <a href="#aa2145cfedf8c4616dacdbf0b7609d8f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a59a49779309642aa9d44ca43b47e5944">unsubscribe</a> (<a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-subscribes from the delivery of signal <em>sig</em> to the active object.  <a href="#a59a49779309642aa9d44ca43b47e5944"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5">defer</a> (<a class="el" href="class_q_e_queue.html">QEQueue</a> *eq, <a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer an event to a given separate event queue.  <a href="#a2b60c62e712768b6fadfa1fd75f910e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa">recall</a> (<a class="el" href="class_q_e_queue.html">QEQueue</a> *eq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall a deferred event from a given event queue.  <a href="#a0ec00766be634a8e71a380a115ecfbaa"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bff20005d080fc888fcbc59b4fd16ab"></a><!-- doxytag: member="QActive::QF" ref="a9bff20005d080fc888fcbc59b4fd16ab" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#a9bff20005d080fc888fcbc59b4fd16ab">QF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab281444c93aa1b1d0525994c9ccc4060"></a><!-- doxytag: member="QActive::QTimeEvt" ref="ab281444c93aa1b1d0525994c9ccc4060" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_active.html#ab281444c93aa1b1d0525994c9ccc4060">QTimeEvt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base class for derivation of application-level active object classes. </p>
<p><a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> is the base class for derivation of active objects. Active objects in <a class="el" href="class_q_f.html" title="QF services.">QF</a> are encapsulated tasks (each embedding a state machine and an event queue) that communicate with one another asynchronously by sending and receiving events. Within an active object, events are processed sequentially in a run-to-completion (RTC) fashion, while <a class="el" href="class_q_f.html" title="QF services.">QF</a> encapsulates all the details of thread-safe event exchange and queuing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> is not intended to be instantiated directly, but rather serves as the base class for derivation of active objects in the application code.</dd></dl>
<p>The following example illustrates how to derive an active object from <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a>. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>Philosopher : <span class="keyword">public</span> QActive {
<span class="keyword">private</span>:
    <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a>  m_num;                             <span class="comment">// number of this philosopher</span>
    <a class="code" href="class_q_time_evt.html" title="Time Event class.">QTimeEvt</a> m_timeEvt;                       <span class="comment">// to timeout thining or eating</span>

<span class="keyword">public</span>:
    Philosopher::Philosopher()
    : QActive((<a class="code" href="qep_8h.html#ac2c368a1ec5e2037c5f4d54f24b3da95" title="pointer to state-handler function">QStateHandler</a>)&amp;Philosopher::initial),
      m_timeEvt(TIMEOUT_SIG)
    {}

<span class="keyword">protected</span>:
    <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> initial (Philosopher *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
    <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> thinking(Philosopher *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
    <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> hungry  (Philosopher *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
    <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> eating  (Philosopher *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
};
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a693fe2fdd4b701be0836f7cad7ee7e45" title="The macro defining the base class for QActive.">QF_ACTIVE_SUPER_</a> defines the base class for <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00113">113</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad6830d1617b22f521d06e3e6c184519e"></a><!-- doxytag: member="QActive::QActive" ref="ad6830d1617b22f521d06e3e6c184519e" args="(QF_ACTIVE_STATE_ initial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QActive::QActive </td>
          <td>(</td>
          <td class="paramtype">QF_ACTIVE_STATE_&#160;</td>
          <td class="paramname"><em>initial</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>protected constructor </p>
<p>Performs the first step of active object initialization by assigning the initial pseudostate to the currently active state of the state machine.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The constructor is protected to prevent direct instantiation of <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> objects. This class is intended only for derivation (abstract class). </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00261">261</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2b60c62e712768b6fadfa1fd75f910e5"></a><!-- doxytag: member="QActive::defer" ref="a2b60c62e712768b6fadfa1fd75f910e5" args="(QEQueue *eq, QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::defer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defer an event to a given separate event queue. </p>
<p>This function is part of the event deferral support. An active object uses this function to defer an event <em>e</em> to the QF-supported native event queue <em>eq</em>. <a class="el" href="class_q_f.html" title="QF services.">QF</a> correctly accounts for another outstanding reference to the event and will not recycle the event at the end of the RTC step. Later, the active object might recall one event at a time from the event queue.</p>
<p>An active object can use multiple event queues to defer events of different kinds.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a>, <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a> </dd></dl>

<p>Definition at line <a class="el" href="lint__qf_8txt_source.html#l00009">9</a> of file <a class="el" href="lint__qf_8txt_source.html">lint_qf.txt</a>.</p>

</div>
</div>
<a class="anchor" id="a29d494a0802145fdaf510ccc89c61dce"></a><!-- doxytag: member="QActive::get_" ref="a29d494a0802145fdaf510ccc89c61dce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const * QActive::get_ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an event from the event queue of an active object. </p>
<p>This function is used internally by a <a class="el" href="class_q_f.html" title="QF services.">QF</a> port to extract events from the event queue of an active object. This function depends on the event queue implementation and is sometimes implemented in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port (qf_port.cpp file). Depending on the underlying OS or kernel, the function might block the calling thread when no events are available.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_q_active.html#a29d494a0802145fdaf510ccc89c61dce" title="Get an event from the event queue of an active object.">QActive::get_()</a> is public because it often needs to be called from thread-run routines with difficult to foresee signature (so declaring friendship with such function(s) is not possible.)</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive::postFIFO()</a>, <a class="el" href="class_q_active.html#a6c2deb168c17567ab6bbc2178d67878d" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive::postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__get___8cpp_source.html#l00041">41</a> of file <a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qevent_8h_source.html#l00141">QEvent::dynamic_</a>, <a class="el" href="qk_8h_source.html#l00129">QACTIVE_EQUEUE_ONEMPTY_</a>, <a class="el" href="qk_8h_source.html#l00098">QACTIVE_EQUEUE_WAIT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00069">QS_QF_ACTIVE_GET</a>, <a class="el" href="qs_8h_source.html#l00070">QS_QF_ACTIVE_GET_LAST</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>.</p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00060">QF::run()</a>, and <a class="el" href="qa__run_8cpp_source.html#l00035">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a46f02154787a4f0f0ac91638251da82a"></a><!-- doxytag: member="QActive::postFIFO" ref="a46f02154787a4f0f0ac91638251da82a" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::postFIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Posts an event <em>e</em> directly to the event queue of the acitve object <em>me</em> using the First-In-First-Out (FIFO) policy. </p>
<p>Direct event posting is the simplest asynchronous communication method available in <a class="el" href="class_q_f.html" title="QF services.">QF</a>. The following example illustrates how the Philosopher active obejct posts directly the HUNGRY event to the Table active object. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">extern</span> QActive *AO_Table;

<a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Philosopher::hungry(Philosopher *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e) {
    TableEvt *pe;
    <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d" title="signal of the event instance">sig</a>) {
        <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe" title="signal for entry actions">Q_ENTRY_SIG</a>: {
            pe = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(TableEvt, HUNGRY_SIG);    <span class="comment">// dynamically allocate event</span>
            pe-&gt;philNum = me-&gt;num_;
            AO_Table-&gt;<a class="code" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">postFIFO</a>(pe);               <span class="comment">// post the event directly</span>
            <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
        }
        . . .
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>);
}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The producer of the event (Philosopher in this case) must only "know" the recipient (Table) by a generic (<a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> *QDPP_table) pointer, but the specific definition of the Table class is not required.</dd>
<dd>
Direct event posting should not be confused with direct event dispatching. In contrast to asynchronous event posting through event queues, direct event dispatching is synchronous. Direct event dispatching occurs when you call <a class="el" href="class_q_hsm.html#ac2a3d63618bd223ecaf114f878e4934b" title="Dispatches an event to a HSM.">QHsm::dispatch()</a>, or <a class="el" href="class_q_fsm.html#a857376b5adf5803e2a397517b0bd9cb1" title="Dispatches an event to a FSM.">QFsm::dispatch()</a> function. </dd></dl>

<p>Definition at line <a class="el" href="qa__fifo_8cpp_source.html#l00041">41</a> of file <a class="el" href="qa__fifo_8cpp_source.html">qa_fifo.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00114">QACTIVE_EQUEUE_SIGNAL_</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00067">QS_QF_ACTIVE_POST_FIFO</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qf__tick_8cpp_source.html#l00038">QF::tick()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c2deb168c17567ab6bbc2178d67878d"></a><!-- doxytag: member="QActive::postLIFO" ref="a6c2deb168c17567ab6bbc2178d67878d" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::postLIFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Posts an event directly to the event queue of the active object <em>me</em> using the Last-In-First-Out (LIFO) policy. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The LIFO policy should be used only with great caution because it alters order of events in the queue. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive::postFIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__lifo_8cpp_source.html#l00041">41</a> of file <a class="el" href="qa__lifo_8cpp_source.html">qa_lifo.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00114">QACTIVE_EQUEUE_SIGNAL_</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00068">QS_QF_ACTIVE_POST_LIFO</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qa__defer_8cpp_source.html#l00043">recall()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ec00766be634a8e71a380a115ecfbaa"></a><!-- doxytag: member="QActive::recall" ref="a0ec00766be634a8e71a380a115ecfbaa" args="(QEQueue *eq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> const * QActive::recall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_e_queue.html">QEQueue</a> *&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recall a deferred event from a given event queue. </p>
<p>This function is part of the event deferral support. An active object uses this function to recall a deferred event from a given <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue. Recalling an event means that it is removed from the deferred event queue <em>eq</em> and posted (LIFO) to the event queue of the active object.</p>
<p><a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a> returns the pointer to the recalled event to the caller. The function returns NULL if no event has been recalled.</p>
<p>An active object can use multiple event queues to defer events of different kinds.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5" title="Defer an event to a given separate event queue.">QActive::defer()</a>, <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a>, <a class="el" href="class_q_active.html#a6c2deb168c17567ab6bbc2178d67878d" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive::postLIFO()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__defer_8cpp_source.html#l00043">43</a> of file <a class="el" href="qa__defer_8cpp_source.html">qa_defer.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00141">QEvent::dynamic_</a>, <a class="el" href="qeq__get_8cpp_source.html#l00038">QEQueue::get()</a>, <a class="el" href="qa__lifo_8cpp_source.html#l00041">postLIFO()</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, and <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>.</p>

</div>
</div>
<a class="anchor" id="a0cea14cd2b9f2f2b5a8185625eed99d0"></a><!-- doxytag: member="QActive::run" ref="a0cea14cd2b9f2f2b5a8185625eed99d0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Traditional loop-structured thread routine for an active object. </p>
<p>This function is only used when <a class="el" href="class_q_f.html" title="QF services.">QF</a> is ported to a traditional RTOS/Kernel. <a class="el" href="class_q_active.html#a0cea14cd2b9f2f2b5a8185625eed99d0" title="Traditional loop-structured thread routine for an active object.">QActive::run()</a> is structured as a typical endless loop, which blocks on the event queue get() operation of an active object. When an event becomes available, it's dispatched to the active object's state machine and after this recycled with <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a>. The loop might optionally use the <a class="el" href="class_q_active.html#a39ad6e0e372e7e1734867e8e6b22ddcc" title="The Boolean loop variable determining if the thread routine of the active object is running...">QActive::m_running</a> flag to terminate and cause <a class="el" href="class_q_active.html#a0cea14cd2b9f2f2b5a8185625eed99d0" title="Traditional loop-structured thread routine for an active object.">QActive::run()</a> to return which is often the cleanest way to terminate the thread. </p>

<p>Definition at line <a class="el" href="qa__run_8cpp_source.html#l00035">35</a> of file <a class="el" href="qa__run_8cpp_source.html">qa_run.cpp</a>.</p>

<p>References <a class="el" href="qf__gc_8cpp_source.html#l00038">QF::gc()</a>, <a class="el" href="qa__get___8cpp_source.html#l00041">get_()</a>, and <a class="el" href="qf_8h_source.html#l00160">m_running</a>.</p>

</div>
</div>
<a class="anchor" id="aedb01d8ba6b6de77c8b72df057abe336"></a><!-- doxytag: member="QActive::start" ref="aedb01d8ba6b6de77c8b72df057abe336" args="(uint8_t prio, QEvent const *qSto[], uint32_t qLen, void *stkSto, uint32_t stkSize, QEvent const *ie=(QEvent *) 0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>qLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stkSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>stkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>ie</em> = <code>(<a class="el" href="struct_q_event.html">QEvent</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts execution of an active object and registers the object with the framework. </p>
<p>The function takes six arguments. <em>prio</em> is the priority of the active object. <a class="el" href="class_q_f.html" title="QF services.">QF</a> allows you to start up to 63 active objects, each one having a unique priority number between 1 and 63 inclusive, where higher numerical values correspond to higher priority (urgency) of the active object relative to the others. <em>qSto</em>[] and <em>qLen</em> arguments are the storage and size of the event queue used by this active object. <em>stkSto</em> and <em>stkSize</em> are the stack storage and size in bytes. Please note that a per-active object stack is used only when the underlying OS requies it. If the stack is not required, or the underlying OS allocates the stack internally, the <em>stkSto</em> should be NULL and/or <em>stkSize</em> should be 0. <em>ie</em> is an optional initialization event that can be used to pass additional startup data to the active object. (Pass NULL if your active object does not expect the initialization event).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and must be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port to a particular platform.</dd></dl>
<p>The following example shows starting of the Philosopher object when a per-task stack is required: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> Philosopher   l_philo[N];               <span class="comment">// N Philosopher active objects</span>
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *l_philQueueSto[N][N];   <span class="comment">// storage for Philo event queues</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> l_philoStk[N][256];    <span class="comment">// stacks for the Philosopher active objects</span>

main() {
    . . .
    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {
        TableEvt ie;           <span class="comment">// initialization event for the Philosopher HSM</span>
        ie.philNum = n;
        l_philo[n].start((<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a>)(n*10 + 1),                      <span class="comment">// priority</span>
                      l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),  <span class="comment">// queue</span>
                      l_philoStk[n], <span class="keyword">sizeof</span>(l_philoStk[n]),  <span class="comment">// uC/OS-II stack</span>
                      &amp;ie);                            <span class="comment">// initialization event</span>
    }
    . . .
}
</pre></div> 
<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00085">85</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00150">m_prio</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qf__port_8h_source.html#l00056">QF_MAX_ACTIVE</a>, and <a class="el" href="qs_8h_source.html#l00958">QS_FLUSH</a>.</p>

</div>
</div>
<a class="anchor" id="ad2001894b640ac76f5779f6beb87b694"></a><!-- doxytag: member="QActive::stop" ref="ad2001894b640ac76f5779f6beb87b694" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops execution of an active object and removes it from the framework's supervision. </p>
<p>The preferred way of calling this function is from within the active object that needs to stop (that's why this function is protected). In other words, an active object should stop itself rather than being stopped by some other entity. This policy works best, because only the active object itself "knows" when it has reached the appropriate state for the shutdown.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and should be defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port to a particular platform. This function is optional in embedded systems where active objects never need to be stopped. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00101">101</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qf__act_8cpp_source.html#l00077">QF::remove_()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2145cfedf8c4616dacdbf0b7609d8f2"></a><!-- doxytag: member="QActive::subscribe" ref="aa2145cfedf8c4616dacdbf0b7609d8f2" args="(QSignal sig) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subscribes for delivery of signal <em>sig</em> to the active object. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Subscribing to an event means that the framework will start posting all published events with a given signal <em>sig</em> to the event queue of the active object.</p>
<p>The following example shows how the Table active object subscribes to three signals in the initial transition: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Table::initial(Table *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *) {
    <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a> n;
    me-&gt;subscribe(HUNGRY_SIG);                          <span class="comment">// subscribe to HUNGRY</span>
    me-&gt;subscribe(DONE_SIG);                              <span class="comment">// subscribe to DONE</span>
    me-&gt;subscribe(TERMINATE_SIG);                    <span class="comment">// subscribe to TERMINATE</span>
    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {
        me-&gt;fork_[n] = FREE;
        me-&gt;isHungry_[n] = 0;
    }
    <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Table::serving);
}
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317" title="Publish event to the framework.">QF::publish()</a>, <a class="el" href="class_q_active.html#a59a49779309642aa9d44ca43b47e5944" title="Un-subscribes from the delivery of signal sig to the active object.">QActive::unsubscribe()</a>, and <a class="el" href="class_q_active.html#a36aa82f457ec53ab04b3f6b69a67f72c" title="Un-subscribes from the delivery of all signals to the active object.">QActive::unsubscribeAll()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__sub_8cpp_source.html#l00038">38</a> of file <a class="el" href="qa__sub_8cpp_source.html">qa_sub.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">QF::active_</a>, <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00091">Q_ROM_BYTE</a>, <a class="el" href="qep_8h_source.html#l00256">Q_USER_SIG</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00059">QF_div8Lkup</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__port_8h_source.html#l00056">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8cpp_source.html#l00037">QF_maxSignal_</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00035">QF_pwr2Lkup</a>, <a class="el" href="qf__psini_8cpp_source.html#l00036">QF_subscrList_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00065">QS_QF_ACTIVE_SUBSCRIBE</a>, and <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>.</p>

</div>
</div>
<a class="anchor" id="a59a49779309642aa9d44ca43b47e5944"></a><!-- doxytag: member="QActive::unsubscribe" ref="a59a49779309642aa9d44ca43b47e5944" args="(QSignal sig) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-subscribes from the delivery of signal <em>sig</em> to the active object. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Un-subscribing from an event means that the framework will stop posting published events with a given signal <em>sig</em> to the event queue of the active object.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to the latency of event queues, an active object should NOT assume that a given signal <em>sig</em> will never be dispatched to the state machine of the active object after un-subscribing from that signal. The event might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events.</dd>
<dd>
Un-subscribing from a signal that has never been subscribed in the first place is considered an error and <a class="el" href="class_q_f.html" title="QF services.">QF</a> will rise an assertion.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317" title="Publish event to the framework.">QF::publish()</a>, <a class="el" href="class_q_active.html#aa2145cfedf8c4616dacdbf0b7609d8f2" title="Subscribes for delivery of signal sig to the active object.">QActive::subscribe()</a>, and <a class="el" href="class_q_active.html#a36aa82f457ec53ab04b3f6b69a67f72c" title="Un-subscribes from the delivery of all signals to the active object.">QActive::unsubscribeAll()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__usub_8cpp_source.html#l00038">38</a> of file <a class="el" href="qa__usub_8cpp_source.html">qa_usub.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">QF::active_</a>, <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00091">Q_ROM_BYTE</a>, <a class="el" href="qep_8h_source.html#l00256">Q_USER_SIG</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00059">QF_div8Lkup</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00047">QF_invPwr2Lkup</a>, <a class="el" href="qf__port_8h_source.html#l00056">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8cpp_source.html#l00037">QF_maxSignal_</a>, <a class="el" href="qf__psini_8cpp_source.html#l00036">QF_subscrList_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00066">QS_QF_ACTIVE_UNSUBSCRIBE</a>, and <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>.</p>

</div>
</div>
<a class="anchor" id="a36aa82f457ec53ab04b3f6b69a67f72c"></a><!-- doxytag: member="QActive::unsubscribeAll" ref="a36aa82f457ec53ab04b3f6b69a67f72c" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive::unsubscribeAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-subscribes from the delivery of all signals to the active object. </p>
<p>This function is part of the Publish-Subscribe event delivery mechanism available in <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Un-subscribing from all events means that the framework will stop posting any published events to the event queue of the active object.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to the latency of event queues, an active object should NOT assume that no events will ever be dispatched to the state machine of the active object after un-subscribing from all events. The events might be already in the queue, or just about to be posted and the un-subscribe operation will not flush such events. Also, the alternative event-delivery mechanisms, such as direct event posting or time events, can be still delivered to the event queue of the active object.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317" title="Publish event to the framework.">QF::publish()</a>, <a class="el" href="class_q_active.html#aa2145cfedf8c4616dacdbf0b7609d8f2" title="Subscribes for delivery of signal sig to the active object.">QActive::subscribe()</a>, and <a class="el" href="class_q_active.html#a59a49779309642aa9d44ca43b47e5944" title="Un-subscribes from the delivery of signal sig to the active object.">QActive::unsubscribe()</a> </dd></dl>

<p>Definition at line <a class="el" href="qa__usuba_8cpp_source.html#l00038">38</a> of file <a class="el" href="qa__usuba_8cpp_source.html">qa_usuba.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">QF::active_</a>, <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00091">Q_ROM_BYTE</a>, <a class="el" href="qep_8h_source.html#l00256">Q_USER_SIG</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00059">QF_div8Lkup</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00047">QF_invPwr2Lkup</a>, <a class="el" href="qf__port_8h_source.html#l00056">QF_MAX_ACTIVE</a>, <a class="el" href="qf__psini_8cpp_source.html#l00037">QF_maxSignal_</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00035">QF_pwr2Lkup</a>, <a class="el" href="qf__psini_8cpp_source.html#l00036">QF_subscrList_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00066">QS_QF_ACTIVE_UNSUBSCRIBE</a>, and <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a70d9ff3bd1838921d2d25223900e0ca8"></a><!-- doxytag: member="QActive::m_prio" ref="a70d9ff3bd1838921d2d25223900e0ca8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> <a class="el" href="class_q_active.html#a70d9ff3bd1838921d2d25223900e0ca8">QActive::m_prio</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_q_f.html" title="QF services.">QF</a> priority associated with the active object. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a> </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00150">150</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

<p>Referenced by <a class="el" href="qf__act_8cpp_source.html#l00044">QF::getVersion()</a>, <a class="el" href="qf__act_8cpp_source.html#l00077">QF::remove_()</a>, and <a class="el" href="qvanilla_8cpp_source.html#l00085">start()</a>.</p>

</div>
</div>
<a class="anchor" id="a39ad6e0e372e7e1734867e8e6b22ddcc"></a><!-- doxytag: member="QActive::m_running" ref="a39ad6e0e372e7e1734867e8e6b22ddcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> <a class="el" href="class_q_active.html#a39ad6e0e372e7e1734867e8e6b22ddcc">QActive::m_running</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Boolean loop variable determining if the thread routine of the active object is running. </p>
<p>This flag is only used with the traditional loop-structured thread routines. Clearing this flag breaks out of the thread loop, which is often the cleanest way to terminate the thread. The following example illustrates the thread routine for Win32: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="class_q_active.html#a0cea14cd2b9f2f2b5a8185625eed99d0" title="Traditional loop-structured thread routine for an active object.">QActive::run</a>(<span class="keywordtype">void</span>) {
    <span class="keywordflow">do</span> {
        <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e;
        QACTIVE_GET_(<span class="keyword">this</span>, e);                               <span class="comment">// wait for event</span>
        dispatch(e);    <span class="comment">// dispatch event to the active object&#39;s state machine</span>
        <a class="code" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc</a>(e);      <span class="comment">// check if the event is garbage, and collect it if so</span>
    } <span class="keywordflow">while</span> (<a class="code" href="class_q_active.html#a39ad6e0e372e7e1734867e8e6b22ddcc" title="The Boolean loop variable determining if the thread routine of the active object is running...">m_running</a>);

    <a class="code" href="class_q_active.html#a36aa82f457ec53ab04b3f6b69a67f72c" title="Un-subscribes from the delivery of all signals to the active object.">unsubscribeAll</a>();                          <span class="comment">// unsubscribe from all signals</span>
    <a class="code" href="class_q_f.html#a0032e774fcf6293d2136e960fcc48528" title="Remove the active object from the framework.">QF::remove_</a>(<span class="keyword">this</span>);            <span class="comment">// remove this object from any subscriptions</span>
}
</pre></div> 
<p>Definition at line <a class="el" href="qf_8h_source.html#l00160">160</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

<p>Referenced by <a class="el" href="qa__run_8cpp_source.html#l00035">run()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qf_8h_source.html">qf.h</a></li>
<li>lint_qf.txt</li>
<li><a class="el" href="qa__defer_8cpp_source.html">qa_defer.cpp</a></li>
<li><a class="el" href="qa__fifo_8cpp_source.html">qa_fifo.cpp</a></li>
<li><a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a></li>
<li><a class="el" href="qa__lifo_8cpp_source.html">qa_lifo.cpp</a></li>
<li><a class="el" href="qa__run_8cpp_source.html">qa_run.cpp</a></li>
<li><a class="el" href="qa__sub_8cpp_source.html">qa_sub.cpp</a></li>
<li><a class="el" href="qa__usub_8cpp_source.html">qa_usub.cpp</a></li>
<li><a class="el" href="qa__usuba_8cpp_source.html">qa_usuba.cpp</a></li>
<li><a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a></li>
<li><a class="el" href="qk_8cpp_source.html">qk.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
