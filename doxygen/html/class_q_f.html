<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: QF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>QF Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="QF" -->
<p><a class="el" href="class_q_f.html" title="QF services.">QF</a> services.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qf_8h_source.html">qf.h</a>&gt;</code></p>

<p><a href="class_q_f-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b">init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_q_f.html" title="QF services.">QF</a> initialization.  <a href="#a6ad3fc234e46c8a32ea9458533db229b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33">psInit</a> (<a class="el" href="class_q_subscr_list.html">QSubscrList</a> *subscrSto, <a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> maxSignal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <a href="#a3ce01adc2cf6db212a036306ee03bd33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d">poolInit</a> (void *poolSto, <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> poolSize, QEventSize evtSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <a href="#a5defbf03f35eb4bcef9eee150e42821d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369">run</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to <a class="el" href="class_q_f.html" title="QF services.">QF</a> to run the application.  <a href="#a09b2df3e8eb5f22cd401cd637c40f369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2">onStartup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup <a class="el" href="class_q_f.html" title="QF services.">QF</a> callback.  <a href="#a27e969500c797c2939cf8bec05273be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47">onCleanup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup <a class="el" href="class_q_f.html" title="QF services.">QF</a> callback.  <a href="#a9569a5e1a10e536650109855cd89af47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c">stop</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the <a class="el" href="class_q_f.html" title="QF services.">QF</a> application and return control to the OS/Kernel.  <a href="#a1a8e5a6ad959cd7cf52eed88cbdad20c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317">publish</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to the framework.  <a href="#a35ad8ba7e1f1bce525b80d5156465317"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b">tick</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="#a1e53786c3f398cf9c37d5a02ead5a79b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e">getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_q_f.html" title="QF services.">QF</a> version.  <a href="#aea5335373a13d20f56099a0cfdfa723e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a8753eb3f87b739ddf49fd73357a762d1">getPortVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QF-port version.  <a href="#a8753eb3f87b739ddf49fd73357a762d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a7b72df3c92fc6ead554963443762ca22">getPoolMargin</a> (<a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> poolId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event pool.  <a href="#a7b72df3c92fc6ead554963443762ca22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#af6cc651557aaa4040db1995982b1244f">getQueueMargin</a> (<a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> prio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event queue.  <a href="#af6cc651557aaa4040db1995982b1244f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_q_event.html">QEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a0372670610b5d72a5e985503e2ba0b6b">new_</a> (<a class="el" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> evtSize, <a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a> sig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="class_q_f.html" title="QF services.">QF</a> implementation of the dynamic event allocator.  <a href="#a0372670610b5d72a5e985503e2ba0b6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c">gc</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <a href="#a10497af0567c730737b33e46cf2ffd6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a0032e774fcf6293d2136e960fcc48528">remove_</a> (<a class="el" href="class_q_active.html">QActive</a> const *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the active object from the framework.  <a href="#a0032e774fcf6293d2136e960fcc48528"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_q_active.html">QActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a82e692a5232ab9f5226168f345a2af11">active_</a> []</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">array of registered active objects  <a href="#a82e692a5232ab9f5226168f345a2af11"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd057458f70978840c6f18b891ea07f"></a><!-- doxytag: member="QF::QActive" ref="a1bd057458f70978840c6f18b891ea07f" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a1bd057458f70978840c6f18b891ea07f">QActive</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_q_f.html" title="QF services.">QF</a> services. </p>
<p>This class groups together <a class="el" href="class_q_f.html" title="QF services.">QF</a> services. It has only static members and should not be instantiated. </p>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00614">614</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a10497af0567c730737b33e46cf2ffd6c"></a><!-- doxytag: member="QF::gc" ref="a10497af0567c730737b33e46cf2ffd6c" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recycle a dynamic event. </p>
<p>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;attrQF__ attribute.) Next, the function decrements the reference counter of the event, and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated. The pool-of-origin information is stored in the upper 2-MSBs of the e-&gt;attrQF__ attribute.)</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_q_f.html" title="QF services.">QF</a> invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have NO need to call <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a> directly. The <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a>). Such queues are processed outside of <a class="el" href="class_q_f.html" title="QF services.">QF</a> and the automatic garbage collection CANNOT be performed for these events. In this case you need to call <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a> explicitly. </dd></dl>

<p>Definition at line <a class="el" href="qf__gc_8cpp_source.html#l00038">38</a> of file <a class="el" href="qf__gc_8cpp_source.html">qf_gc.cpp</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00172">QF_EPOOL_PUT_</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__pool_8cpp_source.html#l00040">QF_maxPool_</a>, <a class="el" href="qf__pool_8cpp_source.html#l00039">QF_pool_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00083">QS_QF_GC</a>, <a class="el" href="qs_8h_source.html#l00082">QS_QF_GC_ATTEMPT</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00060">run()</a>, and <a class="el" href="qa__run_8cpp_source.html#l00035">QActive::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b72df3c92fc6ead554963443762ca22"></a><!-- doxytag: member="QF::getPoolMargin" ref="a7b72df3c92fc6ead554963443762ca22" args="(uint8_t poolId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> QF::getPoolMargin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the margin of the given event pool. </p>
<p>This function returns the margin of the given event pool <em>poolId</em>, where poolId is the ID of the pool initialized by the call to <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a>. The poolId of the first initialized pool is 1, the second 2, and so on.</p>
<p>The returned pool margin is the minimal number of free blocks encountered in the given pool since system startup.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Requesting the margin of an un-initialized pool raises an assertion in the <a class="el" href="class_q_f.html" title="QF services.">QF</a>. </dd></dl>

<p>Definition at line <a class="el" href="qmp__get_8cpp_source.html#l00062">62</a> of file <a class="el" href="qmp__get_8cpp_source.html">qmp_get.cpp</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__pool_8cpp_source.html#l00040">QF_maxPool_</a>, and <a class="el" href="qf__pool_8cpp_source.html#l00039">QF_pool_</a>.</p>

</div>
</div>
<a class="anchor" id="a8753eb3f87b739ddf49fd73357a762d1"></a><!-- doxytag: member="QF::getPortVersion" ref="a8753eb3f87b739ddf49fd73357a762d1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM *Q_ROM_VAR QF::getPortVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QF-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QF-port version string is "1.1.03".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e" title="Returns the QF version.">QF::getVersion()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00046">46</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00059">Q_ROM</a>.</p>

</div>
</div>
<a class="anchor" id="af6cc651557aaa4040db1995982b1244f"></a><!-- doxytag: member="QF::getQueueMargin" ref="af6cc651557aaa4040db1995982b1244f" args="(uint8_t prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> QF::getQueueMargin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the margin of the given event queue. </p>
<p>This function returns the margin of the given event queue of an active object with priority <em>prio</em>. (<a class="el" href="class_q_f.html" title="QF services.">QF</a> priorities start with 1 and go up to <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.) The margin is the minimal number of free events encountered in the given queue since system startup.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="class_q_f.html#af6cc651557aaa4040db1995982b1244f" title="This function returns the margin of the given event queue.">QF::getQueueMargin()</a> is available only when the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue implementation is used. Requesting the queue margin of an unused priority level raises an assertion in the <a class="el" href="class_q_f.html" title="QF services.">QF</a>. (A priority level becomes used in <a class="el" href="class_q_f.html" title="QF services.">QF</a> after the call to the QF::add_() function.) </dd></dl>

<p>Definition at line <a class="el" href="qa__get___8cpp_source.html#l00082">82</a> of file <a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">active_</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, and <a class="el" href="qf__port_8h_source.html#l00056">QF_MAX_ACTIVE</a>.</p>

</div>
</div>
<a class="anchor" id="aea5335373a13d20f56099a0cfdfa723e"></a><!-- doxytag: member="QF::getVersion" ref="aea5335373a13d20f56099a0cfdfa723e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char Q_ROM *Q_ROM_VAR QF::getVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="class_q_f.html" title="QF services.">QF</a> version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the version string is "3.1.03".</p>
<p>The following example illustrates the usage of this function: </p>
<div class="fragment"><pre class="fragment">printf(<span class="stringliteral">&quot;Quantum DPP\nQEP %s\nQF  %s, QF port %s\n&quot;</span>
       <span class="stringliteral">&quot;Press ESC to quit...\n&quot;</span>,
       <a class="code" href="class_q_e_p.html#a6ebe00c8d3227c7421885eee6d626f06" title="get the current QEP version number string">QEP::getVersion</a>(),                                       <span class="comment">// QEP version</span>
       <a class="code" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e" title="Returns the QF version.">QF::getVersion</a>(),                                         <span class="comment">// QF version</span>
       <a class="code" href="class_q_f.html#a8753eb3f87b739ddf49fd73357a762d1" title="Returns the QF-port version.">QF::getPortVersion</a>());                               <span class="comment">// QF-port version</span>
</pre></div> 
<p>Definition at line <a class="el" href="qf__act_8cpp_source.html#l00044">44</a> of file <a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">active_</a>, <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qf_8h_source.html#l00150">QActive::m_prio</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00059">Q_ROM</a>, <a class="el" href="qevent_8h_source.html#l00075">Q_ROM_VAR</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qevent_8h_source.html#l00044">QP_VERSION</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00063">QS_QF_ACTIVE_ADD</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad3fc234e46c8a32ea9458533db229b"></a><!-- doxytag: member="QF::init" ref="a6ad3fc234e46c8a32ea9458533db229b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="class_q_f.html" title="QF services.">QF</a> initialization. </p>
<p>This function initializes <a class="el" href="class_q_f.html" title="QF services.">QF</a> and must be called exactly once before any other <a class="el" href="class_q_f.html" title="QF services.">QF</a> function. </p>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00051">51</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>Referenced by <a class="el" href="lint__qk_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a0372670610b5d72a5e985503e2ba0b6b"></a><!-- doxytag: member="QF::new_" ref="a0372670610b5d72a5e985503e2ba0b6b" args="(uint16_t evtSize, QSignal sig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> * QF::new_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a>&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal <a class="el" href="class_q_f.html" title="QF services.">QF</a> implementation of the dynamic event allocator. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The application code should not call this function directly. Please use the macro <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__new_8cpp_source.html#l00038">38</a> of file <a class="el" href="qf__new_8cpp_source.html">qf_new.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00141">QEvent::dynamic_</a>, <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00156">QF_EPOOL_EVENT_SIZE_</a>, <a class="el" href="qk_8h_source.html#l00164">QF_EPOOL_GET_</a>, <a class="el" href="qf__pool_8cpp_source.html#l00040">QF_maxPool_</a>, <a class="el" href="qf__pool_8cpp_source.html#l00039">QF_pool_</a>, <a class="el" href="qs_8h_source.html#l00669">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00680">QS_END_</a>, <a class="el" href="qs_8h_source.html#l00612">QS_INT_LOCK_KEY_</a>, <a class="el" href="qs_8h_source.html#l00081">QS_QF_NEW</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, and <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a9569a5e1a10e536650109855cd89af47"></a><!-- doxytag: member="QF::onCleanup" ref="a9569a5e1a10e536650109855cd89af47" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void QF::onCleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup <a class="el" href="class_q_f.html" title="QF services.">QF</a> callback. </p>
<p><a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback.">QF::onCleanup()</a> is called in some <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports before <a class="el" href="class_q_f.html" title="QF services.">QF</a> returns to the underlying operating system or RTOS.</p>
<p>This function is strongly platform-specific and is not implemented in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> but either in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port or in the Board Support Package (BSP) for the given application. Some <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports might not require implementing <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback.">QF::onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init()</a> and <a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> </dd></dl>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00055">stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a27e969500c797c2939cf8bec05273be2"></a><!-- doxytag: member="QF::onStartup" ref="a27e969500c797c2939cf8bec05273be2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void QF::onStartup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Startup <a class="el" href="class_q_f.html" title="QF services.">QF</a> callback. </p>
<p>The timeline for calling <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2" title="Startup QF callback.">QF::onStartup()</a> depends on the particular <a class="el" href="class_q_f.html" title="QF services.">QF</a> port. In most cases, <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2" title="Startup QF callback.">QF::onStartup()</a> is called from <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>, right before starting any multitasking kernel or the background loop. </p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00060">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a5defbf03f35eb4bcef9eee150e42821d"></a><!-- doxytag: member="QF::poolInit" ref="a5defbf03f35eb4bcef9eee150e42821d" args="(void *poolSto, uint32_t poolSize, QEventSize evtSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::poolInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QEventSize&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event pool initialization for dynamic allocation of events. </p>
<p>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used. The arguments are as follows: <em>poolSto</em> is a pointer to the memory block for the events. <em>poolSize</em> is the size of the memory block in bytes. <em>evtSize</em> is the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</p>
<p>You might initialize one, two, and up to three event pools by making one, two, or three calls to the QF_poolInit() function. However, for the simplicity of the internal implementation, you must initialize event pools in the ascending order of the event size.</p>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be used for <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pools. In case such support is missing, <a class="el" href="class_q_f.html" title="QF services.">QF</a> provides a native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event pool implementation. The macro <a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5" title="This macro defines the type of the event pool used in this QF port.">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular <a class="el" href="class_q_f.html" title="QF services.">QF</a> port. See class <a class="el" href="class_q_m_pool.html" title="Native QF memory pool class.">QMPool</a> for more information.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of events available in the pool might be actually less than (<em>poolSize</em> / <em>evtSize</em>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="class_q_f.html#a7b72df3c92fc6ead554963443762ca22" title="This function returns the margin of the given event pool.">QF::getPoolMargin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html" title="QF services.">QF</a> initialization example for <a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init()</a> </dd></dl>

<p>Definition at line <a class="el" href="qf__pool_8cpp_source.html#l00043">43</a> of file <a class="el" href="qf__pool_8cpp_source.html">qf_pool.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00146">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qk_8h_source.html#l00156">QF_EPOOL_EVENT_SIZE_</a>, <a class="el" href="qk_8h_source.html#l00147">QF_EPOOL_INIT_</a>, and <a class="el" href="qf__pool_8cpp_source.html#l00040">QF_maxPool_</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce01adc2cf6db212a036306ee03bd33"></a><!-- doxytag: member="QF::psInit" ref="a3ce01adc2cf6db212a036306ee03bd33" args="(QSubscrList *subscrSto, QSignal maxSignal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::psInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_subscr_list.html">QSubscrList</a> *&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#a5dae830cf35fbe668a3fa2b47452a36b">QSignal</a>&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish-subscribe initialization. </p>
<p>This function initializes the publish-subscribe facilities of <a class="el" href="class_q_f.html" title="QF services.">QF</a> and must be called exactly once before any subscriptions/publications occur in the application. The arguments are as follows: <em>subscrSto</em> is a pointer to the array of subscriber-lists. <em>maxSignal</em> is the dimension of this array and at the same time the maximum signal that can be published or subscribed.</p>
<p>The array of subscriber-lists is indexed by signals and provides mapping between the signals and subscirber-lists. The subscriber- lists are bitmasks of type <a class="el" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a>, each bit in the bitmask corresponding to the unique priority of an active object. The size of the <a class="el" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a> bitmask depends on the value of the <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> macro.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The publish-subscribe facilities are optional, meaning that you might choose not to use publish-subscribe. In that case calling <a class="el" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33" title="Publish-subscribe initialization.">QF::psInit()</a> and using up memory for the subscriber-lists is unnecessary.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a></dd></dl>
<p>The following example shows the typical initialization sequence of <a class="el" href="class_q_f.html" title="QF services.">QF</a>: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// allocate storage for active objects, event queues, event pools,</span>
<span class="comment">// subscriber lists, and stacks.</span>
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *l_tableQueueSto[N_PHILO];
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *l_philoQueueSto[N_PHILO][N_PHILO];
<span class="keyword">static</span> <a class="code" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a>   l_subscrSto[MAX_PUB_SIG];

<span class="keyword">static</span> <span class="keyword">union </span>SmallEvents {
    <span class="keywordtype">void</span> *min_size;
    TableEvt te;
    <span class="comment">// other event types to go into this pool</span>
} l_smlPoolSto[2*N_PHILO];                 <span class="comment">// storage for the small event pool</span>

<span class="comment">//............................................................................</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {

    BSP_init(argc, argv);                               <span class="comment">// initialize the BSP</span>

    <a class="code" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init</a>();       <span class="comment">// initialize the framework and the underlying RT kernel</span>

    <a class="code" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33" title="Publish-subscribe initialization.">QF::psInit</a>(l_subscrSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));     <span class="comment">// init publish-subscribe</span>

                                                  <span class="comment">// initialize event pools...</span>
    <a class="code" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));

                                                <span class="comment">// start the active objects...</span>
    <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a> n;
    <span class="keywordflow">for</span> (n = 0; n &lt; N_PHILO; ++n) {
        AO_Philo[n]-&gt;start((<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a>)(n + 1),
                           l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),
                           (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *)0);
    }
    AO_Table-&gt;<a class="code" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">start</a>((<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a>)(N_PHILO + 1),
                    l_tableQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tableQueueSto),
                    (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *)0);

    <a class="code" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run</a>();                                       <span class="comment">// run the QF application</span>

    <span class="keywordflow">return</span> 0;
}
</pre></div> 
<p>Definition at line <a class="el" href="qf__psini_8cpp_source.html#l00040">40</a> of file <a class="el" href="qf__psini_8cpp_source.html">qf_psini.cpp</a>.</p>

<p>References <a class="el" href="qf__psini_8cpp_source.html#l00037">QF_maxSignal_</a>.</p>

</div>
</div>
<a class="anchor" id="a35ad8ba7e1f1bce525b80d5156465317"></a><!-- doxytag: member="QF::publish" ref="a35ad8ba7e1f1bce525b80d5156465317" args="(QEvent const *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Publish event to the framework. </p>
<p>This function posts (using the FIFO policy) the event <em>e</em> it to ALL active object that have subscribed to the signal <em>e-&gt;sig</em>. This function is designed to be callable from any part of the system, including ISRs, device drivers, and active objects.</p>
<p>In the general case, event publishing requires multi-casting the event to multiple subscribers. This happens in the caller's thread with the scheduler locked to prevent preemptions during the multi- casting process. (Please note that the interrupts are not locked.) </p>

<p>Definition at line <a class="el" href="qf__pspub_8cpp_source.html#l00038">38</a> of file <a class="el" href="qf__pspub_8cpp_source.html">qf_pspub.cpp</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00095">Q_ASSERT</a>, <a class="el" href="qevent_8h_source.html#l00146">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00091">Q_ROM_BYTE</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00047">QF_invPwr2Lkup</a>, <a class="el" href="qf__log2_8cpp_source.html#l00035">QF_log2Lkup</a>, <a class="el" href="qf__psini_8cpp_source.html#l00037">QF_maxSignal_</a>, <a class="el" href="qf__psini_8cpp_source.html#l00036">QF_subscrList_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00079">QS_QF_PUBLISH</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a0032e774fcf6293d2136e960fcc48528"></a><!-- doxytag: member="QF::remove_" ref="a0032e774fcf6293d2136e960fcc48528" args="(QActive const *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::remove_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the active object from the framework. </p>
<p>This function should not be called by the application directly, only inside the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port. The priority level occupied by the active object is freed-up and can be reused for another active object.</p>
<p>The active object that is removed from the framework can no longer participate in the publish-subscribe event exchange.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function raises an assertion if the priority of the active object exceeds the maximum value <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> or is not used. </dd></dl>

<p>Definition at line <a class="el" href="qf__act_8cpp_source.html#l00077">77</a> of file <a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">active_</a>, <a class="el" href="qs_8h_source.html#l00425">QS::aoObj_</a>, <a class="el" href="qf_8h_source.html#l00150">QActive::m_prio</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00064">QS_QF_ACTIVE_REMOVE</a>, and <a class="el" href="qs_8h_source.html#l00705">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00101">QActive::stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a09b2df3e8eb5f22cd401cd637c40f369"></a><!-- doxytag: member="QF::run" ref="a09b2df3e8eb5f22cd401cd637c40f369" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfers control to <a class="el" href="class_q_f.html" title="QF services.">QF</a> to run the application. </p>
<p><a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> is typically called from your startup code after you initialize the <a class="el" href="class_q_f.html" title="QF services.">QF</a> and start at least one active object with <a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a>. Also, QF::start() call must precede the transfer of control to <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>, but some <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports might call QF::start() from <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>. <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> typically never returns to the caller.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly platform-dependent and is not implemented in the <a class="el" href="class_q_f.html" title="QF services.">QF</a>, but either in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port or in the Board Support Package (BSP) for the given application. All <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports must implement <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>.</dd>
<dd>
When the Quantum Kernel (<a class="el" href="class_q_k.html" title="QK services.">QK</a>) is used as the underlying real-time kernel for the <a class="el" href="class_q_f.html" title="QF services.">QF</a>, all platfrom dependencies are handled in the <a class="el" href="class_q_k.html" title="QK services.">QK</a>, so no porting of <a class="el" href="class_q_f.html" title="QF services.">QF</a> is necessary. In other words, you only need to recompile the <a class="el" href="class_q_f.html" title="QF services.">QF</a> platform-independent code with the compiler for your platform, but you don't need to provide any platform-specific implementation (so, no qf_port.cpp file is necessary). Moreover, <a class="el" href="class_q_k.html" title="QK services.">QK</a> implements the function <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> in a platform-independent way, in the modile <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a>. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00060">60</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00904">active_</a>, <a class="el" href="qpset_8h_source.html#l00157">QPSet64::findMax()</a>, <a class="el" href="qf__gc_8cpp_source.html#l00038">gc()</a>, <a class="el" href="qa__get___8cpp_source.html#l00041">QActive::get_()</a>, <a class="el" href="qpset_8h_source.html#l00067">QPSet8::notEmpty()</a>, <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2">onStartup()</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, and <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>.</p>

<p>Referenced by <a class="el" href="lint__qk_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a8e5a6ad959cd7cf52eed88cbdad20c"></a><!-- doxytag: member="QF::stop" ref="a1a8e5a6ad959cd7cf52eed88cbdad20c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function invoked by the application layer to stop the <a class="el" href="class_q_f.html" title="QF services.">QF</a> application and return control to the OS/Kernel. </p>
<p>This function stops the <a class="el" href="class_q_f.html" title="QF services.">QF</a> application. After calling this function, <a class="el" href="class_q_f.html" title="QF services.">QF</a> attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this funcition is for terminating the <a class="el" href="class_q_f.html" title="QF services.">QF</a> application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<p>This function is strongly platform-specific and is not implemented in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> but either in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port or in the Board Support Package (BSP) for the given application. Some <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports might not require implementing <a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> at all, because many embedded application don't have anything to exit to.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> and <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback.">QF::onCleanup()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00055">55</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47">onCleanup()</a>.</p>

<p>Referenced by <a class="el" href="lint__qk_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e53786c3f398cf9c37d5a02ead5a79b"></a><!-- doxytag: member="QF::tick" ref="a1e53786c3f398cf9c37d5a02ead5a79b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF::tick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processes all armed time events at every clock tick. </p>
<p>This function must be called periodically from a time-tick ISR or from the highest-priority task so that <a class="el" href="class_q_f.html" title="QF services.">QF</a> can manage the timeout events.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a> function is not reentrant meaning that it must run to completion before it is called again. Also, <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a> assumes that it never will get preempted by a task, which is always the case when it is called from an ISR or the highest-priority task.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_q_time_evt.html" title="Time Event class.">QTimeEvt</a>.</dd></dl>
<p>The following example illustrates the call to <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a>: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// case 1: Interrupt Controller available,</span>
<span class="comment">// &quot;unconditional interrupt unlocking&quot; critical section policy</span>
<span class="comment">// (nesting of critical sections _not_ allowed)</span>
<span class="comment">//</span>
interrupt <span class="keywordtype">void</span> ISR_timer() {     <span class="comment">// entered with interrupts locked in hardware</span>
    <a class="code" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>(dummy);                                 <span class="comment">// unlock interrupts</span>

    <a class="code" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick</a>();                              <span class="comment">//&lt;-- call the QF tick processing</span>

    <a class="code" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a>(dummy);                               <span class="comment">// lock interrupts again</span>
    <span class="comment">// send the EOI instruction to the Interrupt Controller</span>
}

<span class="comment">// case 2: Interrupt Controller not used,</span>
<span class="comment">// &quot;saving and restoring interrupt status&quot; critical section policy</span>
<span class="comment">// (nesting of critical sections allowed)</span>
<span class="comment">//</span>
interrupt <span class="keywordtype">void</span> ISR_timer() {
    <a class="code" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick</a>();                              <span class="comment">//&lt;-- call the QF tick processing</span>
}
</pre></div> 
<p>Definition at line <a class="el" href="qf__tick_8cpp_source.html#l00038">38</a> of file <a class="el" href="qf__tick_8cpp_source.html">qf_tick.cpp</a>.</p>

<p>References <a class="el" href="qa__fifo_8cpp_source.html#l00041">QActive::postFIFO()</a>, <a class="el" href="qf__pkg_8h_source.html#l00057">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00047">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00067">QF_INT_UNLOCK_</a>, <a class="el" href="qte__arm_8cpp_source.html#l00038">QF_timeEvtListHead_</a>, <a class="el" href="qs_8h_source.html#l00689">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00700">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00726">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00084">QS_QF_TICK</a>, <a class="el" href="qs_8h_source.html#l00086">QS_QF_TIMEEVT_AUTO_DISARM</a>, <a class="el" href="qs_8h_source.html#l00090">QS_QF_TIMEEVT_POST</a>, <a class="el" href="qep_8h_source.html#l00271">QS_SIG_</a>, <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>, <a class="el" href="qs_8h_source.html#l00428">QS::teObj_</a>, and <a class="el" href="qs_8h_source.html#l00434">QS::tickCtr_</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a82e692a5232ab9f5226168f345a2af11"></a><!-- doxytag: member="QF::active_" ref="a82e692a5232ab9f5226168f345a2af11" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_active.html">QActive</a> * <a class="el" href="class_q_f.html#a82e692a5232ab9f5226168f345a2af11">QF::active_</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>array of registered active objects </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not to be used by Clients directly, only in ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00904">904</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8cpp_source.html#l00082">getQueueMargin()</a>, <a class="el" href="qf__act_8cpp_source.html#l00044">getVersion()</a>, <a class="el" href="qf__act_8cpp_source.html#l00077">remove_()</a>, <a class="el" href="qvanilla_8cpp_source.html#l00060">run()</a>, <a class="el" href="qa__sub_8cpp_source.html#l00038">QActive::subscribe()</a>, <a class="el" href="qa__usub_8cpp_source.html#l00038">QActive::unsubscribe()</a>, and <a class="el" href="qa__usuba_8cpp_source.html#l00038">QActive::unsubscribeAll()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qf_8h_source.html">qf.h</a></li>
<li><a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a></li>
<li><a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a></li>
<li><a class="el" href="qf__gc_8cpp_source.html">qf_gc.cpp</a></li>
<li><a class="el" href="qf__new_8cpp_source.html">qf_new.cpp</a></li>
<li><a class="el" href="qf__pool_8cpp_source.html">qf_pool.cpp</a></li>
<li><a class="el" href="qf__psini_8cpp_source.html">qf_psini.cpp</a></li>
<li><a class="el" href="qf__pspub_8cpp_source.html">qf_pspub.cpp</a></li>
<li><a class="el" href="qf__tick_8cpp_source.html">qf_tick.cpp</a></li>
<li><a class="el" href="qmp__get_8cpp_source.html">qmp_get.cpp</a></li>
<li><a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a></li>
<li><a class="el" href="qk_8cpp_source.html">qk.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
