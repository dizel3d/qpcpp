<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: 7. Coding Hierarchical State Machines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C++ Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C++ Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>7. Coding Hierarchical State Machines </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C++ Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a> <br/>
 Next: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a></p>
<p>Contrary to widespread misconceptions, you don't need big design automation tools to translate hierarchical state machines (UML statecharts) into efficient and highly maintainable C or C++. This section explains how to hand-code the Ship state machine from <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> with the help of the <a class="el" href="class_q_f.html" title="QF services.">QF</a> real-time framework and the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> hierarchical processor, which is also part of the QP event-driven platform. Once you know how to code this state machine, you know how to code them all.</p>
<p>The source code for the Ship state machine is found in the file <code>ship.cpp</code> located either in the DOS version or the ARM-Cortex version of the "Fly 'n'
Shoot" game. I break the explanation of this file into <b>three</b> steps.</p>
<h2><a class="anchor" id="step1"></a>
7.1 Step 1: Defining the Ship Structure</h2>
<p>In the first step you define the Ship data structure. Just like in case of events, you use inheritance to derive the Ship structure from the framework structure <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> (see the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>). Creating this inheritance relationship ties the Ship structure to the <a class="el" href="class_q_f.html" title="QF services.">QF</a> framework. The main responsibility of the <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> base structure is to store the information about the current active state of the state machine, as well as the event queue and priority level of the Ship active object. In fact, <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> itself derives from a simpler <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> structure <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> that represents just the current active state of a hierarchical state machine. On top of that information, almost every state machine must also store other "extended-state" information. For example, the Ship object is responsible for maintaining the Ship position as well as the score accumulated in the game. You supply this additional information by means of data members enlisted after the base structure member super, as shown in <a class="el" href="coding_hsm.html#L7s1">Listing 7-1</a>.</p>
<p><a class="anchor" id="L7s1"></a> <b>Listing 7-1 Deriving the Ship structure in file ship.cpp.</b> </p>
<div class="fragment"><pre class="fragment"> (1) #include <span class="stringliteral">&quot;qp_port.h&quot;</span>
 (2) #include <span class="stringliteral">&quot;bsp.h&quot;</span>
 (3) #include <span class="stringliteral">&quot;game.h&quot;</span>

 (4) class Ship 
 (5)     : public <a class="code" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a>                               <span class="comment">// extend the QActive class</span>
     {                      
 (6)     <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a> m_x;
 (7)     <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a> m_y;
 (8)     <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924" title="C99 exact-width 8-bit unsigned int.">uint8_t</a> m_exp_ctr;
 (9)     <a class="code" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30" title="C99 exact-width 16-bit unsigned int.">uint16_t</a> m_score;

     <span class="keyword">public</span>:
(10)     Ship(<span class="keywordtype">void</span>) : QActive((<a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a>)&amp;Ship::initial),
                      m_x(GAME_SHIP_X), m_y(GAME_SHIP_Y) {}
     <span class="keyword">private</span>:
(11)     <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> active   (Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
(12)     <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> parked   (Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
(13)     <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> flying   (Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
(14)     <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> exploding(Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);

(15)     <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> initial  (Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e);
     };

(16) <span class="keyword">static</span> Ship l_ship;             <span class="comment">// the sole instance of the Ship active object</span>

     <span class="comment">// global objects ------------------------------------------------------------</span>
(17) QActive * <span class="keyword">const</span> AO_Ship = &amp;l_ship;                <span class="comment">// opaque pointer to Ship AO</span>
</pre></div><ul>
<li>(1) Every application-level C-file that uses the QP platform must include the <code><a class="el" href="qp__port_8h_source.html">qp_port.h</a></code> header file.</li>
</ul>
<ul>
<li>(2) The <code>bsp.h</code> header file contains the interface to the Board Support Package.</li>
</ul>
<ul>
<li>(3) The <code>game.h</code> header file contains the declarations of events and other facilities shared among the components of the application (see <a class="el" href="events.html#L6s1">Listing 6-1</a>).</li>
</ul>
<ul>
<li>(4) This class defines the Ship active object.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>I like to keep active objects, and indeed all state machine objects (such as Mines), strictly encapsulated. Therefore, I don't put the state machine class definitions in header files but rather define them right in the implementation file, such as ship.cpp. That way, I can be sure that the internal data members of the Ship structure are not known to any other parts of the application.</dd></dl>
<ul>
<li>(5) The Ship active object class derives from the framework base class <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a>.</li>
</ul>
<ul>
<li>(6-7) The m_x and m_y data members represent the position of the Ship on the display.</li>
</ul>
<ul>
<li>(8) The m_exp_ctr member is used for pacing the explosion animation (see also the "exploding" state in the Ship state diagram in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>).</li>
</ul>
<ul>
<li>(9) The m_score member stores the accumulated score in the game.</li>
</ul>
<ul>
<li>(10) Every derived active object class is responsible for initializing the part inherited from the base class. The constructor <a class="el" href="class_q_active.html#ad6830d1617b22f521d06e3e6c184519e" title="protected constructor">QActive::QActive()</a> puts the state machine in the initial pseudostate &amp;Ship::initial.</li>
</ul>
<ul>
<li>(11-14) These four functions are called state-handler functions because they correspond one-to-one to the states of the Ship state machine shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. For example, the <code>active()</code> function represents the "active" state. The <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor calls the state handler functions to realize the UML semantics of state machine execution. A state handler function takes the state machine pointer and the event pointer as arguments, and returns the status of the operation back to the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor, for example whether the event was handled or not. The return type QState is typedef-ed to <code>uint8_t</code> in the header file <code>&lt;qpcpp&gt;\include\<a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a></code>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The state-handler functions are necessarily <b>static</b> members of the class, so that they don't use the "this-calling convention". Please see the <a class="el" href="coding_hsm.html#S7s1">Sidebar: Pointers to Member Functions in C++</a>.</dd></dl>
<ul>
<li>(15) In addition to state handler functions, every state machine must declare the initial pseudostate, which <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> invokes to execute the top-most initial transition (see <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1)). The initial pseudostate handler has signature almost identical to the regular state handler function, except it returns void.</li>
</ul>
<ul>
<li>(16) In this line I statically allocate the storage for the Ship active object. Please note that the object l_ship is defined static, so that it is accessible only locally at the file scope of the ship.cpp file.</li>
</ul>
<ul>
<li>(17) In this line I define and initialize the global pointer AO_Ship to the Ship active object (see also <a class="el" href="events.html#L6s1">Listing 6-1</a>(10)). This pointer is "opaque", because it treats the Ship object as the generic <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> base structure, rather than the specific Ship structure. The power of an "opaque" pointer is that it allows me to completely hide the definition of the Ship structure and make it inaccessible to the rest of the application. Still, the other application components can access the Ship object to post events directly to it via the AO_Ship-&gt;postFIFO(evt) member function call.</li>
</ul>
<p><a class="anchor" id="S7s1"></a> </p>
<table  summary="Pointers to Member Functions in C++" cellspacing="4" cellpadding="1" border="0" align="center" valign="middle">
<tr bgcolor="#f0f0f0">
<td><p class="starttd"><b>Sidebar: Pointers to Member Functions in C++</b></p>
<p>The C++ state handler function takes the "me" pointer of its own class type, through which it accesses the state machine data members and member functions (e.g., me-&gt;operand1 = ...). This is because the state-handler functions are <b>static</b> members of the <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> subclass, such as the Ship state machine class Calc (see <a class="el" href="coding_hsm.html#L7s1">Listing 7-1</a>).</p>
<p>An obvious and more elegant alternative would be to make the state-handler functions regular, non-static class members, which would allow them to access the class members much more naturally through the implicit "this" pointer.</p>
<p>Indeed this much more elegant alternative has been used in the earlier QEP/C++ version published in the first edition of the "Practical Statecharts in
C/C++" book. However, this alternative requires using pointers-to-member-functions instead of simple pointers-to-functions, which turned out to be a problem in practice.</p>
<p>Even though the earlier C++ version of <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> used pointers-to-member-functions in a rather standard way, the embedded developers have filed a number of alarming reports from the trenches where the elegant approach either had very lousy performance, or did not work at all. For example, some embedded C++ compilers used over 30 machine instructions to de-reference a pointer-to-member-function and only 3 to de-reference a regular pointer-to-function. Needless to say, 3 machine instructions should do the job.</p>
<p>As it turns out, too many C++ compilers simply don't support pointers-to-member-functions well due to interference of other language features such as multiple inheritance and virtual base classes. As eloquently explained in the online article "Member Function Pointers and the Fastest
Possible C++ Delegates" (see "Member Function Pointers and the Fastest
Possible C++ Delegates" at <a href="http://www.codeproject.com/cpp/FastDelegate.asp">http://www.codeproject.com/cpp/FastDelegate.asp</a>), even such widespread and important frameworks as the MFC actually use pointers-to-member-functions in a non-standard way by subverting the normal C++ type checking.</p>
<p class="endtd">To avoid inefficiencies and portability issues, the current C++ version of <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> does <b>not</b> to use pointers-to-member-functions, but simply plain pointers-to-functions to <b>static</b> member functions that don't have the "this" pointer and therefore are not affected by polymorphism or multiple inheritance. Please note that the explicit "me" pointer required by static class members plays the same role as the "context" pointer required by the object-oriented State design pattern (see Chapter 3 in <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>).   </p>
</td></tr>
</table>
<h2><a class="anchor" id="step2"></a>
7.2 Step 2: Initializing the State Machine</h2>
<p>The state machine initialization is divided into the following two steps for increased flexibility and better control of the initialization timeline:</p>
<ol type="1">
<li>The state machine constructor; and</li>
<li>The top-most initial transition.</li>
</ol>
<p>The state machine constructor, such as <code>Ship::Ship()</code> (see <a class="el" href="coding_hsm.html#L7s1">Listing 7-1</a>(10)), intentionally does not execute the top-most initial transition defined in the initial pseudostate because at that time some vital objects can be missing and critical hardware might not be properly initialized yet. Instead, the state machine constructor merely puts the state machine in the initial pseudostate. Later, the user code must trigger the top-most initial transition explicitly, which happens actually inside the function <a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a> (see <a class="el" href="main_function.html#L3s1">Listing 3-11</a>(15-17)). <a class="el" href="coding_hsm.html#L7s2">Listing 7-2</a> shows the initialization (the initial pseudostate) of the Ship active object.</p>
<p><a class="anchor" id="L7s2"></a> <b>Listing 7-2 Instantiation and Initialization of the Ship active object in ship.cpp.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship::initial(Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *) {
 (2)     me-&gt;subscribe(TIME_TICK_SIG);
 (3)     me-&gt;subscribe(PLAYER_TRIGGER_SIG);
 (4)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship::active);               <span class="comment">// top-most initial transition</span>
     }
</pre></div><ul>
<li>(1) The Ship::initial() function defines the top-most initial transition in the Ship state machine (see <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1)).</li>
</ul>
<ul>
<li>(2-3) The Ship active object subscribes to signals <code>TIME_TICK_SIG</code> and <code>PLAYER_TRIGGER_SIG</code>, as specified in the state diagram in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1).</li>
</ul>
<ul>
<li>(4) The initial state "active" is specified by invoking the QP macro <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The macro <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> must always follow the return statement.</dd></dl>
<h2><a class="anchor" id="step3"></a>
7.3 Step 3: Defining State Handler Functions</h2>
<p>In the last step, you actually code the Ship state machine by implementing one state at a time as a state handler function. To determine what elements belong the any given state handler function, you follow around the state's boundary in the diagram (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>). You need to implement all transitions originating at the boundary, any entry and exit actions defined in the state, as well as all internal transitions enlisted directly in the state. Additionally, if there is an initial transition embedded directly in the state, you need to implement it as well.</p>
<p>Take for example the state "flying" shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. This state has an entry action and two transitions originating at its boundary: <code>HIT_WALL</code> and <code>HIT_MINE(type)</code>, as well as three internal transitions <code>TIME_TICK</code>, <code>PLAYER_TRIGGER</code>, and <code>DESTROYED_MINE(score)</code>. The "flying" state nests inside the "active" superstate. <a class="el" href="coding_hsm.html#L7s3">Listing 7-3</a> shows two state handler functions of the Ship state machine from <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. The state handler functions correspond to the states "active" and "flying", respectively. The explanation section immediately following the listing highlights the important implementation techniques.</p>
<p><a class="anchor" id="L7s3"></a> <b>Listing 7-3 State handler functions for states "active" and "flying" in ship.cpp.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship::active(Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e) {
 (2)     <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d" title="signal of the event instance">sig</a>) {
 (3)         <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a28691a94425fb031be4044e817e21a60" title="signal for nested initial transitions">Q_INIT_SIG</a>: {                        <span class="comment">// nested initial transition</span>
 (4)             <span class="comment">// any actions associated with the initial transition</span>
 (5)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship::parked);
             }
 (6)         <span class="keywordflow">case</span> PLAYER_SHIP_MOVE_SIG: {
 (7)             me-&gt;m_x = ((ObjectPosEvt <span class="keyword">const</span> *)e)-&gt;x;
 (8)             me-&gt;m_y = ((ObjectPosEvt <span class="keyword">const</span> *)e)-&gt;y;
 (9)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
         }
(10)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>);
     }
     <span class="comment">//............................................................................</span>
     <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship::flying(Ship *me, <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> <span class="keyword">const</span> *e) {
         <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d" title="signal of the event instance">sig</a>) {
(11)         <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe" title="signal for entry actions">Q_ENTRY_SIG</a>: {
(12)             ScoreEvt *sev;

                 me-&gt;m_score = 0;                                <span class="comment">// reset the score</span>
(13)             sev = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ScoreEvt, SCORE_SIG);
(14)             sev-&gt;score = me-&gt;m_score;
(15)             AO_Tunnel-&gt;postFIFO(sev);
(16)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> TIME_TICK_SIG: {
                 <span class="comment">// tell the Tunnel to draw the Ship and test for hits</span>
                 ObjectImageEvt *oie = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ObjectImageEvt, SHIP_IMG_SIG);
                 oie-&gt;x   = me-&gt;m_x;
                 oie-&gt;y   = me-&gt;m_y;
                 oie-&gt;bmp = SHIP_BMP;
                 AO_Tunnel-&gt;postFIFO(oie);

                 ++me-&gt;m_score;   <span class="comment">// increment the score for surviving another tick</span>

                 <span class="keywordflow">if</span> ((me-&gt;m_score % 10) == 0) {            <span class="comment">// is the score &quot;round&quot;?</span>
                     ScoreEvt *sev = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ScoreEvt, SCORE_SIG);
                     sev-&gt;score = me-&gt;m_score;
                     AO_Tunnel-&gt;postFIFO(sev);
                 }

                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> PLAYER_TRIGGER_SIG: {                      <span class="comment">// trigger the Missile</span>
                 ObjectPosEvt *ope = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ObjectPosEvt, MISSILE_FIRE_SIG);
                 ope-&gt;x = me-&gt;m_x;
                 ope-&gt;y = me-&gt;m_y + SHIP_HEIGHT - 1;
                 AO_Missile-&gt;postFIFO(ope);
                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> DESTROYED_MINE_SIG: {
                 me-&gt;m_score += ((ScoreEvt <span class="keyword">const</span> *)e)-&gt;score;
                 <span class="comment">// the score will be sent to the Tunnel by the next TIME_TICK</span>
                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
(17)         <span class="keywordflow">case</span> HIT_WALL_SIG:
(18)         <span class="keywordflow">case</span> HIT_MINE_SIG: {
(19)             <span class="comment">// any actions associated with the transition</span>
(20)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship::exploding);
             }
         }
(21)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;Ship::active);
     }
</pre></div><ul>
<li>(1) Each state handler must have the same signature, that is, it must take two parameters: the state machine pointer "me" and the pointer to <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a>. The keyword const before the '*' in the event pointer declaration means that the event pointed to by that pointer cannot be changed inside the state handler function (i.e., the event is read-only). A state handler function must return QState, which conveys the status of the event handling to the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor.</li>
</ul>
<ul>
<li>(2) Typically, every state handler is structured as a switch statement that discriminates based on the signal of the event signal e-&gt;sig.</li>
</ul>
<ul>
<li>(3) This line of code pertains to the nested initial transition <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(2). <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> provides a reserved signal <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a28691a94425fb031be4044e817e21a60" title="signal for nested initial transitions">Q_INIT_SIG</a> that the framework passes to the state handler function when it wants to execute the initial transition.</li>
</ul>
<ul>
<li>(4) You can enlist any actions associated with this initial transition (none in this particular case).</li>
</ul>
<ul>
<li>(5) You designate the target substate with the <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> macro. This macro must always follow the return statement, through which the state handler function informs the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor that the transition has been taken.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The initial transition must necessarily target a direct or transitive substate of a given state. An initial transition cannot target a peer state or go up in state hierarchy to higher-level states, which in the UML would represent a "malformed" state machine.</dd></dl>
<ul>
<li>(6) This line of code pertains to the internal transition <code>PLAYER_SHIP_MOVE_SIG(x, y)</code> in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(3).</li>
</ul>
<ul>
<li>(7-8) You access the data members of the Ship state machine via the "me" argument of the state handler function. You access the event parameters via the "e" argument. You need to cast the event pointer from the generic <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> base class to the specific event structure expected for the <code>PLAYER_SHIP_MOVE_SIG</code>, which is <code>ObjectPosEvt</code> in this case.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The association between the event signal and event structure (event parameters) is established at the time the event is generated. All recipients of that event must know about this association to perform the cast to the correct event structure.</dd></dl>
<ul>
<li>(9) You terminate the case statement with <code>return <a class="el" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED()</a></code>, which informs QP that the initial transition has been handled.</li>
</ul>
<ul>
<li>(10) The final return from a state handler function designates the superstate of that state by means of the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> macro <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a>. The final return statement from a state handler function represents the single point of maintenance for changing the nesting level of a given state. The state "active" in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> has no explicit superstate, which means that it is implicitly nested in the "top" state. The "top" state is a UML concept that denotes the ultimate root of the state hierarchy in a hierarchical state machine. <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> provides the "top" state as a state handler function <a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top()</a>, and therefore the Ship::active() state handler returns the pointer &amp;<a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>In C++, a pointer-to-function <a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top()</a> can be written either as <a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>, or &amp;<a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>. Even though the notation <a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a> is more succinct, I prefer adding the ampersand explicitly, to leave absolutely no doubt that I mean a pointer-to-function &amp;<a class="el" href="class_q_hsm.html#aee07933d134a725a2556fef24e0e3154" title="the top-state.">QHsm::top</a>.</dd></dl>
<ul>
<li>(11) This line of code pertains to the entry action into state "flying" (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(5)). <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> provides a reserved signal <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe" title="signal for entry actions">Q_ENTRY_SIG</a> that the framework passes to the state handler function when it wants to execute the entry actions.</li>
</ul>
<ul>
<li>(12) The entry action to "flying" posts the SCORE event to the Tunnel active object (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(5)). This line defines a temporary pointer to the event structure ScoreEvt.</li>
</ul>
<ul>
<li>(13) The <a class="el" href="class_q_f.html" title="QF services.">QF</a> macro <code><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW(ScoreEvt, SCORE_SIG)</a></code> dynamically allocates an instance of the ScoreEvt from an event pool managed by <a class="el" href="class_q_f.html" title="QF services.">QF</a>. The macro also performs the association between the signal <code>SCORE_SIG</code> and the allocated event. The <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> macro returns the pointer to the allocated event.</li>
</ul>
<ul>
<li>(14) The score parameter of the ScoreEvt is set from the state machine member <code>me-&gt;score</code>.</li>
</ul>
<ul>
<li>(15) The <code>SCORE(me-&gt;score)</code> event is posted directly to the Tunnel active object by means of the QP function <a class="el" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive::postFIFO()</a>. The arguments of this function are the recipient active object (<code>AO_Tunnel</code> in this case) and the pointer to the event (the temporary pointer sev in this case).</li>
</ul>
<ul>
<li>(16) You terminate the case statement with <code>return <a class="el" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED()</a></code>, which informs <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> that the entry actions have been handled.</li>
</ul>
<ul>
<li>(17-18) These two lines of code pertain to the state transitions from "flying" to "exploding" (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(9, 10)).</li>
</ul>
<ul>
<li>(19) You can enlist any actions associated with the transition (none in this particular case).</li>
</ul>
<ul>
<li>(20) You designate the target of the transition with the <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> macro.</li>
</ul>
<ul>
<li>(21) The final return from a state handler function designates the superstate of that state. The state "flying" in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> nests in the state "active", so the state handler <code>Ship::flying()</code> returns the pointer &amp;Ship::active wrapped with the macro <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a>.</li>
</ul>
<p>When implementing state handler functions you need to keep in mind that the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor is in charge here rather than your code. <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> will invoke a state handler function for various reasons: for hierarchical event processing, for execution of entry and exit actions, for triggering initial transitions, or even just to elicit the superstate of a given state handler. Therefore, you should not assume that a state handler would be invoked only for processing signals enlisted in the case statements. You should avoid any code outside the switch statement, especially code that would have side effects.</p>
<p>Prev: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a> <br/>
 Next: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
