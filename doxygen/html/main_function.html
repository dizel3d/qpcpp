<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: 3. The main() Function</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C++ Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C++ Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>3. The main() Function </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C++ Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br/>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a></p>
<p>Perhaps the best place to start the explanation of the "Fly 'n' Shoot" application code is the main() function, located in the file <code>main.cpp</code>. Unless indicated otherwise in this Tutorial, you can browse the code either in the DOS version, or the ARM-Cortex version, because the application source code is identical in both. The complete <code>main.cpp</code> file is shown in <a class="el" href="main_function.html#L3s1">Listing 3-1</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To explain code listings, I place numbers in parentheses at the interesting lines in the left margin of the listing. I then use these labels in the left margin of the explanation section that immediately follows the listing. Occasionally, to unambiguously refer to a line of a particular listing from sections of text other than the explanation section, I use the full reference consisting of the listing number followed by the label. For example, <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(18) refers to the label (18) in <a class="el" href="main_function.html#L3s1">Listing 3-1</a></dd></dl>
<p><a class="anchor" id="L3s1"></a> <b>Listing 3-1 The file main.cpp of the "Fly 'n' Shoot" game application. </b> </p>
<div class="fragment"><pre class="fragment"> (1) #include <span class="stringliteral">&quot;qp_port.h&quot;</span>
 (2) #include <span class="stringliteral">&quot;bsp.h&quot;</span>
 (3) #include <span class="stringliteral">&quot;game.h&quot;</span>

     <span class="comment">// Local-scope objects -------------------------------------------------------</span>
 (4) static <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> const * l_missileQueueSto[2];
 (5) static <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> const * l_shipQueueSto[3];
 (6) static <a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> const * l_tunnelQueueSto[GAME_MINES_MAX + 5];
 (7) static ObjectPosEvt   l_smlPoolSto[GAME_MINES_MAX + 5];    <span class="comment">// small event pool</span>
 (8) static ObjectImageEvt l_medPoolSto[GAME_MINES_MAX + 5];   <span class="comment">// medium event pool</span>
 (9) static <a class="code" href="class_q_subscr_list.html" title="Subscriber List class.">QSubscrList</a>    l_subscrSto[MAX_PUB_SIG];

     <span class="comment">//............................................................................</span>
     <span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {

(10)     BSP_init(argc, argv);              <span class="comment">// initialize the Board Support Package</span>

(11)     <a class="code" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init</a>();       <span class="comment">// initialize the framework and the underlying RT kernel</span>

                                                   <span class="comment">// initialize the event pools...</span>
(12)     <a class="code" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));
(13)     <a class="code" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit</a>(l_medPoolSto, <span class="keyword">sizeof</span>(l_medPoolSto), <span class="keyword">sizeof</span>(l_medPoolSto[0]));

(14)     <a class="code" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33" title="Publish-subscribe initialization.">QF::psInit</a>(l_subscrSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));     <span class="comment">// init publish-subscribe</span>

                                                     <span class="comment">// start the active objects...</span>
(15)     AO_Missile-&gt;start(1,                                           <span class="comment">// priority</span>
                           l_missileQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_missileQueueSto),<span class="comment">// evt queue</span>
                           (<span class="keywordtype">void</span> *)0, 0,                     <span class="comment">// no per-thread stack</span>
                           (<a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *)0);                 <span class="comment">// no initialization event</span>
(16)     AO_Ship   -&gt;start(2,                                           <span class="comment">// priority</span>
                           l_shipQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_shipQueueSto),      <span class="comment">// evt queue</span>
                           (<span class="keywordtype">void</span> *)0, 0,                     <span class="comment">// no per-thread stack</span>
                           (<a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *)0);                 <span class="comment">// no initialization event</span>
(17)     AO_Tunnel -&gt;start(3,                                           <span class="comment">// priority</span>
                           l_tunnelQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tunnelQueueSto),  <span class="comment">// evt queue</span>
                           (<span class="keywordtype">void</span> *)0, 0,                     <span class="comment">// no per-thread stack</span>
                           (<a class="code" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *)0);                 <span class="comment">// no initialization event</span>

(18)     <a class="code" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run</a>();                                       <span class="comment">// run the QF application</span>
     }
</pre></div><ul>
<li>(1) The "Fly 'n' Shoot" game is an example of an application implemented with the QP event-driven platform. Every application C-file that uses QP must include the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. This header file contains the specific adaptation of QP to the given processor, operating system, and compiler, which is called a port. Each QP port is located in a separate directory and the C compiler finds the right <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file through the include search path provided to the compiler (typically via the -I compiler option). That way I don't need to change the application source code to recompile it for a different processor or compiler. I only need to instruct the compiler to look in a different QP port directory for the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. For example, the DOS version includes the <code><a class="el" href="qp__port_8h_source.html">qp_port.h</a></code> header file from the directory <code>&lt;qpcpp&gt;\ports\80x86\dos\watcom\l\</code>, and the ARM-Cortex version from the directory <code>&lt;qpcpp&gt;\ports\arm-cortex\vanilla\iar\</code>.</li>
</ul>
<ul>
<li>(2) The bsp.h header file contains the interface to the Board Support Package and is located in the application directory.</li>
</ul>
<ul>
<li>(3) The game.h header file contains the declarations of events and other facilities shared among the components of the application. I will discuss this header file in the upcoming Section <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a>. This header file is located in the application directory.</li>
</ul>
<p>The QP event-driven platform is a collection of components, such as the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor that executes state machines according to the UML semantics and the <a class="el" href="class_q_f.html" title="QF services.">QF</a> real-time framework that implements the active object computing model. Active objects in <a class="el" href="class_q_f.html" title="QF services.">QF</a> are encapsulated state machines (each with an event queue, a separate task context, and a unique priority) that communicate with one another asynchronously by sending and receiving events, while <a class="el" href="class_q_f.html" title="QF services.">QF</a> handles all the details of thread-safe event exchange and queuing. Within an active object, the events are processed by the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor sequentially in a run-to-completion (RTC) fashion, meaning that processing of one event must necessarily complete before processing the next event.</p>
<ul>
<li>(4-6) The application must provide storage for the event queues of all active objects used in the application. Here the storage is provided at compile time through the statically allocated arrays of immutable (const) pointers to events, because <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queues hold just pointers to events, not events themselves. Events are represented as instances of the <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> structure declared in the <a class="el" href="qp__port_8h_source.html">qp_port.h</a> header file. Each event queue of an active object can have a different size and you need to decide this size based on your knowledge of the application. I discuss the event queues in Chapters 6 and 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</li>
</ul>
<ul>
<li>(7-8) The application must also provide storage for event pools that the framework uses for fast and deterministic dynamic allocation of events. Each event pool manages can provide only fixed-size memory blocks. To avoid wasting memory by using oversized blocks for small events, the <a class="el" href="class_q_f.html" title="QF services.">QF</a> framework can manage up to three event pools of different block sizes (for small, medium, and large events). The "Fly 'n' Shoot" application uses only two out of the three possible event pools (the small and medium pools).</li>
</ul>
<p>The <a class="el" href="class_q_f.html" title="QF services.">QF</a> real-time framework supports two event delivery mechanisms: the simple direct event posting to active objects, and the more advanced mechanism called publish-subscribe that decouples event producers from the consumers. In the publish-subscribe mechanism, active objects subscribe to events by the framework. Event producers publish the events to the framework. Upon each publication request, the framework delivers the event to all active objects that had subscribed to that event type. One obvious implication of publish-subscribe is that the framework must store the subscriber information, whereas it must be possible to handle multiple subscribers to any give event type. The event delivery mechanisms are described in Chapters 6 and 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</p>
<ul>
<li>(9) The "Fly 'n' Shoot" application uses the publish-subscribe event delivery mechanism supported by <a class="el" href="class_q_f.html" title="QF services.">QF</a>, so it needs to provide the storage for the subscriber lists. The subscriber lists remembers which active objects have subscribed to which events. The size of the subscriber database depends on both the number of published events, which is specified in the MAX_PUB_SIG constant found in the game.h header file, and the maximum number of active objects allowed in the system, which is determined by the <a class="el" href="class_q_f.html" title="QF services.">QF</a> configuration parameter <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>.</li>
</ul>
<ul>
<li>(10) The function <code>BSP_init()</code> initializes the board and is defined in the bsp.cpp file.</li>
</ul>
<ul>
<li>(11) The function <a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init()</a> initializes the <a class="el" href="class_q_f.html" title="QF services.">QF</a> component and the underlying RTOS/kernel, if such software is used. You need to call <a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization.">QF::init()</a> before you invoke any of <a class="el" href="class_q_f.html" title="QF services.">QF</a> services.</li>
</ul>
<ul>
<li>(12-13) The function <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> initializes the event pools. The parameters of this function are the pointer to the event pool storage, the size of this storage, and the block-size of this pool. You can call this function up to three times to initialize up to three event pools. The subsequent calls to <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> must be made in the increasing order of block sizes. For instance, the small block-size pool must be initialized before the medium block-size pool.</li>
</ul>
<ul>
<li>(14) The function <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit()</a> initializes the publish-subscribe event delivery mechanism of <a class="el" href="class_q_f.html" title="QF services.">QF</a>. The parameters of this function are the pointer to the subscriber-list array and the dimension of this array.</li>
</ul>
<p>The utility macro <a class="el" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM(a)</a> provides the dimension of a one-dimensional array <code>a[]</code> computed as <code>sizeof(a)/sizeof(a[0])</code>, which is a compile-time constant. The use of this macro simplifies the code because it allows me to eliminate many #define constants that otherwise I would need to provide for the dimensions of various arrays. I can simply hard-code the dimension right in the definition of an array, which is the only place that I specify it. I then use the macro <a class="el" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM()</a> whenever I need this dimension in the code.</p>
<ul>
<li>(15-17) The function <a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a> tells the <a class="el" href="class_q_f.html" title="QF services.">QF</a> framework to start managing an active object as part of the application. The function takes the following parameters: the pointer to the active object structure, the priority of the active object, the pointer to its event queue, the dimension (length) of that queue, and three other parameters that I explain in Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>, since they are not relevant at this point. The active object priorities in <a class="el" href="class_q_f.html" title="QF services.">QF</a> are numbered from 1 to <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a>, inclusive, where a higher priority number denotes higher urgency of the active object. The constant <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application.">QF_MAX_ACTIVE</a> is defined in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port header file <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> and currently cannot exceed 63.</li>
</ul>
<p>I like to keep the code and data of every active object strictly encapsulated within its own C-file. For example, all code and data for the active object Ship are encapsulated in the file ship.cpp, with the external interface consisting of the pointer <code>AO_Ship</code>.</p>
<ul>
<li>(18) At this point, you have provided to the framework all the storage and information it needs to manage your application. The last thing you must do is to call the function <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> to pass the control to the framework.</li>
</ul>
<p>After the call to <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> the framework is in full control. The framework executes the application by calling your code, not the other way around. The function <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> never returns the control back to main(). In the DOS version of the "Fly 'n' Shoot" game, you can terminate the application by pressing the ESC key, in which case <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> exits to DOS, but not to <code>main()</code>. In an embedded system, such as the ARM-Cortex board, <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> runs forever or till the power is removed, whichever comes first.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For best cross-platform portability, the source code uses consistently the <b>UNIX end-of-line convention</b> (lines are terminated with LF only, 0xA character). This convention seems to be working for all C/C++ compilers and cross-compilers, including legacy DOS-era tools. In contrast, the DOS/Windows end-of-line convention (lines terminated with the CR,LF, or 0xD,0xA pair of characters), is known to cause problems on UNIX-like platforms, especially in the multi-line preprocessor macros.</dd></dl>
<p>Prev: <a class="el" href="lets_play.html">2. Let's Play</a> <br/>
 Next: <a class="el" href="design.html">4. Designing an Event-Driven Application</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
