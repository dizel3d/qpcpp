<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: QSPY Host Application Reference Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C++ Reference Manual</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>QSPY Host Application Reference Manual </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><div align="center">
<img src="logo_qs_TM.jpg" alt="logo_qs_TM.jpg"/>
</div>
<ul>
<li><a class="el" href="qspy_page.html#qspy_intro_sec">Introduction</a></li>
<li><a class="el" href="qspy_page.html#qspy_command">QSPY Command-Line Parameters</a></li>
<li><a class="el" href="qspy_human_format.html">Human-Readable QSPY Output</a></li>
<li><a class="el" href="qspy_matlab.html">QSPY MATLAB Inteface</a></li>
</ul>
<h2><a class="anchor" id="qspy_intro_sec"></a>
Introduction</h2>
<p>Quantum Spy&trade; (QS) is a real-time tracing instrumentation built into the <a class="el" href="index.html#overview">QP event-driven platform</a>. QS allows you to gain unprecedented visibility into your application by selectively logging almost all interesting events occurring within state machines, the framework, the kernel, and your application code. QS event logging is minimally intrusive, offers precise time-stamping, sophisticated runtime filtering of events, and good data compression. QS can be configured to send the real-time data out of the serial or Ethernet port of the target device, or even write the data to a file. QS is described in Chapter 11 of the book <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>, Newnes 2008.</p>
<p>Every software tracing system consists of a target component and a host component. The host component for the Quantum Spy software tracing system is the <b>QSPY host application</b>. QSPY is a simple console application without any fancy GUI because its purpose is to provide only the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> data parsing, storing,and exporting to such powerful tools as <b>MATLAB</b>. QSPY has been designed from the ground up to be platform-neutral. The application is written in portable C++, and ports to Linux and Windows with various compilers are provided.</p>
<div align="center">
<img src="qspy.jpg" alt="qspy.jpg"/>
<p><strong>A typical setup for collecting software trace data with QSPY</strong></p></div>
<p> QSPY is easily adaptable to various target-host communication links. Out of the box, the QSPY host application supports serial (RS232), TCP/IP, and file communication links. Adding other communication links is easy, because the data link layer is clearly abstracted in a Hardware Abstraction Layer (HAL). The QSPY application accepts several command-line parameters to configure all target dependencies, such as pointer sizes, signal sizes, etc. This means that the single QSPY host application can process data from any target 8-, 16-, or 32-bit.</p>
<p>QSPY provides a simple consolidated, human-readable textual output to the screen. If the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> trace data contains dictionary trace records, QSPY applies this symbolic information to output the provided identifiers for objects, signals, and states. Otherwise, QSPY outputs the hexadecimal values of various pointers and signals. (See Section <a class="el" href="qspy_human_format.html">Human-Readable QSPY Output</a>).</p>
<p>Finally, QSPY can export the trace data in the matrix format readable by MATLAB. Special MATLAB script to import QSPY trace data to MATLAB is provided. Once the data is available in MATLAB matrices, it can be conveniently manipulated and visualized with this powerful tool. (See Section <a class="el" href="qspy_matlab.html">QSPY MATLAB Inteface</a>).</p>
<h2><a class="anchor" id="qspy_command"></a>
QSPY Command-Line Parameters</h2>
<p>The QSPY host application is designed to work with all possible target CPUs and data links, which requires a wide range of configurability. For example, for any given target CPU the QSPY application must "know" the size of object pointers, function pointers, event signals, timestamp size and so on. You provide this information to QSPY by means of command-line parameters, which are summarized in the following table:</p>
<table  summary="QSPY parameters" cellspacing="4" cellpadding="1" border="0" align="center" valign="middle">
<tr bgcolor="#c8cedc">
<td><b>&#160;Option</b> </td><td><b>&#160;Example</b> </td><td><b>&#160;Default</b> </td><td><b>&#160;Must match QP macro<br/>
 (QP port header file)</b> </td><td><p class="starttd"><b>&#160;Comments</b> </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-h </td><td>-h </td><td></td><td></td><td><p class="starttd">Help. Prints the summary of options </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-q </td><td>-q </td><td></td><td></td><td><p class="starttd">Quiet mode (no stdout output) </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-o </td><td>-o qs.txt </td><td></td><td></td><td><p class="starttd">Produce output to the specified file </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-s </td><td>-s qs.spy </td><td></td><td></td><td><p class="starttd">Save the binary input to the specified file. Not compatible with -f  </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-m </td><td>-m qs.mat </td><td></td><td></td><td><p class="starttd">Generates MATLAB output to the specified file </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-c </td><td>-c COM2 </td><td>COM1 </td><td></td><td><p class="starttd">COM port selection. Not compatible with -t, -p, -f </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-b </td><td>-b 115200 </td><td>38400 </td><td></td><td><p class="starttd">Baud rate selection. Not compatible with -t, -p, -f </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-t </td><td>-t </td><td></td><td></td><td><p class="starttd">TCP/IP input selection. Not compatible with -c, -b, -f </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-p </td><td>-p 6602 </td><td>6601 </td><td></td><td><p class="starttd">TCP/IP server port number. Not compatible with -c, -b, -f </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-f </td><td>-f qs.spy </td><td></td><td></td><td><p class="starttd">File input selection. Not compatible with -c, -b, -t, -p </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-T </td><td>-T 2 </td><td>4 </td><td><code><a class="el" href="qs_8h.html#a2495d53a05dadde00fc49675401f9490" title="The size (in bytes) of the QS time stamp. Valid values: 1, 2, or 4; default 4.">QS_TIME_SIZE</a></code>  (<a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a>) </td><td><p class="starttd">Time stamp size in bytes. Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-O </td><td>-O 2 </td><td>4 </td><td><code>QS_OBJ_PTR_SIZE</code>  (<a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a>) </td><td><p class="starttd">Object pointer size in bytes. Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-F </td><td>-F 2 </td><td>4 </td><td><code>#QS_FUN_PTR_SIZE</code>  (<a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a>) </td><td><p class="starttd">Function pointer size in bytes. Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-S </td><td>-S 2 </td><td>1 </td><td><code><a class="el" href="qevent_8h.html#afdaa94c40e947b0340b4259eddce3561" title="The size (in bytes) of the signal of an event. Valid values: 1, 2, or 4; default 1.">Q_SIGNAL_SIZE</a></code>  (<a class="el" href="qep__port_8h.html" title="QEP/C port to QK for a &quot;generic&quot; C compiler.">qep_port.h</a>) </td><td><p class="starttd">Signal size in bytes. Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-E </td><td>-E 1 </td><td>2 </td><td><code><a class="el" href="qf_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="Default value of the macro configurable value in qf_port.h.">QF_EVENT_SIZ_SIZE</a></code>  (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a>) </td><td><p class="starttd">Event-size size in bytes (i.e., the size of variables that hold event size). Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-Q </td><td>-Q 1 </td><td>2 </td><td><code><a class="el" href="qequeue_8h.html#a54463011114f6b076e0bd62e3fa27102" title="The size (in bytes) of the ring-buffer counters used in the native QF event queue implementation...">QF_EQUEUE_CTR_SIZE</a></code>  (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a>) </td><td><p class="starttd">Queue counter size in bytes. Valid values 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-P </td><td>-P 4 </td><td>2 </td><td><code><a class="el" href="qmpool_8h.html#adc446a34e9e682fc5e821d203f73a6e0" title="macro to override the default QMPoolCtr size. Valid values 1, 2, or 4; default 2">QF_MPOOL_CTR_SIZE</a></code>  (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a>) </td><td><p class="starttd">Pool counter size in bytes. Valid values: 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#c0c0c0">
<td>-B </td><td>-B 1 </td><td>2 </td><td><code><a class="el" href="qmpool_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="macro to override the default ::QMPoolSize size. Valid values 1, 2, or 4; default 2...">QF_MPOOL_SIZ_SIZE</a></code>  (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a>) </td><td><p class="starttd">Block size size in bytes. (i.e., the size of variables that hold memory block size). Valid values 1, 2, 4 </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#f0f0f0">
<td>-C </td><td>-C 4 </td><td>2 </td><td><code><a class="el" href="qf_8h.html#a80d059a0d02a2573c76f4eb5df0228ae" title="macro to override the default QTimeEvtCtr size. Valid values 1, 2, or 4; default 2">QF_TIMEEVT_CTR_SIZE</a></code>  (<a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a>) </td><td>Time event counter size. Valid values: 1, 2, 4  </td></tr>
</table>
<p>The QSPY host application is designed to work with all possible target CPUs and data links, which requires a wide range of configurability. For example, for any given target CPU the QSPY application must "know" the size of object pointers, function pointers, event signals, timestamp size and so on. You provide this information to QSPY by means of command-line parameters, which are summarized in table above. Please note that the options are case sensitive.</p>
<p>Your main concern when invoking QSPY is to match exactly the target system you are using. The fourth column of the table above lists the configuration macros used by the target system as well as the platform-specific QP header files where those macros are defined. You need to use the corresponding QSPY command-line option only when the QP macro differs from the default. The default values assumed by QSPY are consistent with the defaults used in QP.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When you do not match the QSPY host application with the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> target component, the QSPY application will be unable to parse correctly the mismatched trace records and will start generating the following errors:</dd></dl>
<div class="fragment"><pre class="fragment">
     ********** 028: Error xx bytes unparsed
     ********** 014: Error -yy bytes unparsed
</pre></div><p>The number in front of the error indicates the Record ID of the trace record that could not be parsed.</p>
<hr/>
<h2><a class="anchor" id="qspy_licensing"></a>
Licensing QSPY</h2>
<p>The QSPY host application is licensed the same way as all other components of the QP event-driven platform. See Section <a class="el" href="index.html#licensing">Licensing Policy for QP</a>.</p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2008 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.quantum-leaps.com">http://www.quantum-leaps.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
