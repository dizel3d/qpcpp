<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C++: QP/C++ Revision History</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>QP/C++ Revision History </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="qpcpp_4_1_06"></a>
Version 4.1.06 (Product) Release date: Jan 07, 2011</h2>
<p>1. Fixed a bug in the software tracing instrumentation in the function <a class="el" href="class_q_f.html#a0032e774fcf6293d2136e960fcc48528" title="Remove the active object from the framework.">QF::remove_()</a>, file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a>.</p>
<p>2. Made cosmetic improvements to the example QM models of the "Fly 'n' Shoot" game.</p>
<p>3. Made improvements in make.bat files for building the examples for DOS/Open Watcom to run better in DosBox on Linux.</p>
<p>4. Upgraded the examples for ARM Cortex with IAR to the latest IAR EWARM version 6.10.</p>
<p>5. Upgraded the examples for ARM Cortex with CodeSourcery to the latest Sourcery G++ 2010.09-66.</p>
<h2><a class="anchor" id="qpcpp_4_1_05"></a>
Version 4.1.05 (Product) Release date: Nov 01, 2010</h2>
<p>This release is adds examples for the QM (QP Modeler) graphical modeling and code generation tool. The examples are based on the "Fly 'n' Shoot" game described in the QP/C++ Tutorial and in Chapter 1 of the PSiCC2 book.</p>
<p>Specifically, the directory &lt;qpcpp&gt;\80x86-qm\ contains the "Fly 'n' Shoot" game model file "game.qm". This model, when opened in the QM tool contains all state machine diagrams and generates code into the subdirectory qm_code\. This code can then be built and executed on any 80x86 machine (newer versions of Windows or Linux require the DOSbox application, see <a href="http://www.dosbox.com">http://www.dosbox.com</a>).</p>
<p>The directory &lt;qpcpp&gt;-cortex-ev-lm3s811-qm\ contains the version of the game for the EV-LM3S811 ARM Cortex-M3 board. This directory contains the model file "game.qm", which is actually identical as the model in the DOS version. The LM3S811 version needs to be compiled with the IAR compiler and executed on the EV-LM3S811 board.</p>
<p>Additionally, the QP/C++ baseline code has been slighlty modified for better conformance to the MISRA C++ 2008 rules and the latest PC-Lint 9.x.</p>
<h2><a class="anchor" id="qpcpp_4_1_04"></a>
Version 4.1.04 (Product) Release date: Mar 16, 2010</h2>
<p>This release is adds compatibility of all examples for DOS with the DOSBox emulator (<a href="http://www.dosbox.com/">http://www.dosbox.com/</a>) that recreates a MS-DOS compatible environment on all versions of Windows, including 64-bit Windows that don't run 16-bit DOS applications anymore.</p>
<p>Also, this release includes QP ports and examples for EV-LM3S811 board with the GNU-based Code Sourcery G++ toolset. Support for Sourcery G++ provides a very cost-effective option for developing QP applications for ARM Cortex MCUs.</p>
<p>Finally, this release improves the Cortex Microcontroller Software Interface Standard (CMSIS) for the whole family of the Stellaris LM3Sxxx MCUs. The improvement extends the CMSIS from Sandstorm to Fury, DustDevil, and Tempest Stellaris families.</p>
<h2><a class="anchor" id="qpcpp_4_1_03"></a>
Version 4.1.03 (Product) Release date: Jan 21, 2010</h2>
<p>This release is concerned with the ARM Cortex ports and examples. Specifically, this release contains the following improvements:</p>
<p>1. Unified source code for ARM Cortex-M3 and the new ARM Cortex-M0 cores, including the code for the preemptive <a class="el" href="class_q_k.html" title="QK services.">QK</a> kernel.</p>
<p>2. Compliance with the Cortex Microcontroller Software Interface Standard (CMSIS) in all ARM Cortex examples.</p>
<p>3. Backward-compatible support for the new LM3S811 EVAL Rev C board with different OLED display than previous revisions. (NOTE: The OSRAM 96x16x1 OLED used in REV A-B boards has been replaced RITEK 96x16x1 OLED used in Rev C.)</p>
<p>In the process of making the examples CMSIS-compliant, the dependency on the Luminary Micro driver library (driverlib.a) has been completely removed.</p>
<p>Additionally, the screen saver of the "Fly 'n' Shoot" game has been improved to periodically switch off the power of the OLED display, which better protects the display from burn-in. The affected file is tunnel.cpp.</p>
<p>Finally, this release introduces the QP_VERSION macro, which identifies the QP version. Otherwise, this maintenance release does not change the QP/C API in any way, so the release has NO IMPACT on the QP/C applications except for the ARM Cortex ports and applications.</p>
<h2><a class="anchor" id="qpcpp_4_1_02"></a>
Version 4.1.02 (Product) Release date: Jan 14, 2010</h2>
<p>The purpose of this minor maintenance release is the change in the directory structure for the ARM Cortex ports and examples. As new ARM Cortex cores are becoming available, the old port name "cortex-m3" could be misleading, because it actually applies to wider range of ARM Cortex cores. Consequently, all ARM Cortex ports and examples are hosted in the directory tree called "arm-cortex".</p>
<p>This maintenance release does not change the QP/C++ API in any way, so the release has NO IMPACT on the QP/C++ applications except for the ARM Cortex ports.</p>
<h2><a class="anchor" id="qpcpp_4_1_01"></a>
Version 4.1.01 (Product) Release date: Nov 05, 2009</h2>
<p>The main purpose of this release is to replace the Turbo C++ 1.01 toolset with the Open Watcom C/C++ toolset, because Turbo C++ 1.01 is no longer available for a free download. In contrast, Open Watcom is distributed under an OSI-certified open source license, which permits free commercial and non-commercial use. Open Watcom can be downloaded from www.openwatcom.org.</p>
<p>All 80x86/DOS and 80x86/qk ports and examples for Turbo C++ 1.01 have been replaced with ports and examples for Open Watcom. The make.bat scripts are provided to build the QP/C++ libraries and examples.</p>
<p>In the process of converting the examples to Open Watcom two new examples have been added to the standard QP/C++ distribution. The Calc2 example located in &lt;qpcpp&gt;\80x86 shows how to derive state machine classes with QP 4.x. The SLS example located in &lt;qpcpp&gt;\80x86 shows the implemenation of the new State-Local Storage state design pattern.</p>
<h2><a class="anchor" id="qpcpp_4_1_00"></a>
Version 4.1.00 (Product) Release date: Oct 09, 2009</h2>
<p>The release provides brings a number of improvements to QP/C++ and updates the QP/C++ ARM Cortex-M3 examples for the EK-LM3S811 board to the latest IAR EWARM 5.40. Due to the acquisition of Liminary Micro by Texas Instruments the directory IAR structure for the examples and drivers has changed and the QP examples had to be changed accordingly.</p>
<p>This maintenance release does not change the QP/C++ API in any way, so the release has NO IMPACT on the QP/C++ applications.</p>
<p>The main changes in QP v4.1.00 with respect to earlier versions are as follows:</p>
<ul>
<li>in <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added a new trace record QS_QEP_DISPATCH logged when an event is dispatched to a state machine. This timestamped trace record marks the beginning of an RTC step. The end of the RTC step is marked by the existing timestamped trace records QS_QEP_INTERN_TRAN, QS_QEP_INIT_TRAN, and QS_QEP_IGNORED, depending on how the event is handled. The new QS_QEP_DISPATCH record facilitates measurement of the RTC step lengths.</li>
<li>in <a class="el" href="qhsm__dis_8cpp.html" title="QHsm::dispatch() implementation.">qhsm_dis.cpp</a> added generation of the QS_QEP_DISPATCH trace record.</li>
<li>in the tools\ sub-directory added output of the new trace record to the Q-SPY host application.</li>
<li>in the tools\ sub-directory added processing of the new trace record to the qspy.m script.</li>
<li>in <a class="el" href="qpset_8h.html" title="platform-independent priority sets of 8 or 64 elements.">qpset.h</a> changed the implementation of the Priority Set. In particular, the <a class="el" href="class_q_p_set64.html" title="Priority Set of up to 64 elements for building various schedulers, but also useful as a general set o...">QPSet64</a> now derives from <a class="el" href="class_q_p_set8.html" title="Priority Set of up to 8 elements for building various schedulers, but also useful as a general set of...">QPSet8</a>, which enables a common way of testing for non-empty set (e.g., useful in assembly). Also, the findMax() functions in <a class="el" href="class_q_p_set8.html" title="Priority Set of up to 8 elements for building various schedulers, but also useful as a general set of...">QPSet8</a> and <a class="el" href="class_q_p_set64.html" title="Priority Set of up to 64 elements for building various schedulers, but also useful as a general set o...">QPSet64</a> now can work with an empty set, in which case they return 0.</li>
<li>in <a class="el" href="qk__sched_8cpp.html" title="QK_schedule_() implementation.">qk_sched.cpp</a> simplified the QK_schedule_() function to skip the testing of the ready-set for non-empty condition. Such test is no longer necessary. The test can still be performed outside the QK_schedule_() function (e.g., in assembly) to avoid calling the scheduler if the ready set is empty.</li>
<li>in <a class="el" href="qk__ext_8cpp.html" title="QK_scheduleExt_() implementation.">qk_ext.cpp</a> simplified the QK_scheduleExt_() function in the same way as QK_schedule_().</li>
<li>modified make.bat files for building QP libraries in the ports\ directory to use the externally defined environment variables for the location of the toolchains. The defaults are applied only when the environment variable is not defined. This enables greater flexibility in installing the development tools in different directories than those chosen by Quantum Leaps.</li>
<li>modified the ARM Cortex-M3 examples for the new IAR EWARM 5.40.</li>
<li>modified slighlty the Calculator example to allow extensibility.</li>
<li>in the ARM Cortex-M3 port file qk_port.s added explicit testing of the QK_readySet_ set for empty condition. This test allows avoiding calling the <a class="el" href="class_q_k.html" title="QK services.">QK</a> scheduler and two contex-switches if the ready-set is empty.</li>
<li>in the game example moved setting up the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> filters from main.cpp to bsp.cpp.</li>
</ul>
<h2><a class="anchor" id="qpcpp_4_0_04"></a>
Version 4.0.04 (Product) Release date: Apr 09, 2009</h2>
<p>The maintenance release introduces the virtual destructor in the <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> and <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> base classes. This is done to allow proper handling of virtual functions in the subclasses of <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> or <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a>. Please note, however, that the change increases the size of every state machine object by the additional (hidden) virtual pointer (vptr).</p>
<p>Also, this release provides a fix for the compile-time assertions, which did not work correctly for the GNU compiler family.</p>
<p>Finally, the ARM Cortex-M3 examples have been recompiled with the newer IAR EWARM v5.30.</p>
<p>This maintenance release does not change the QP/C++ API in any way, so the release has NO IMPACT on the QP/C++ applications.</p>
<p>The main changes in QP v4.0.04 with respect to earlier version are as follows:</p>
<ul>
<li>in <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> file, virtual destructors have been added to <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> and <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a>.</li>
<li>in <a class="el" href="qassert_8h.html" title="Customizable QP assertions.">qassert.h</a> file the <a class="el" href="qassert_8h.html#a17f551ed8492f013d533f27353c091a3">Q_ASSERT_COMPILE</a> macro has been modified to render a negative array dimension when the asserted condition is not TRUE.</li>
</ul>
<h2><a class="anchor" id="qpcpp_4_0_03"></a>
Version 4.0.03 (Product) Release date: Dec 27, 2008</h2>
<p>The main purpose of this release is to fix a bug in the <a class="el" href="class_q_k.html" title="QK services.">QK</a> preemptive kernel, which occurs only when the advanced <a class="el" href="class_q_k.html" title="QK services.">QK</a> features are used. Specifically, the <a class="el" href="class_q_k.html" title="QK services.">QK</a> priority-ceiling mutex could interfere with <a class="el" href="class_q_k.html" title="QK services.">QK</a> thread-local storage (TLS) or <a class="el" href="class_q_k.html" title="QK services.">QK</a> extended context switch. When the <a class="el" href="class_q_k.html" title="QK services.">QK</a> mutex is in use, the TLS or the extended context for this task could get saved to an incorrect priority level.</p>
<p>The release 4.0.03 fixes the bug by strictly preserving the semantics of QK_currPrio_ variable. The mutex locking now uses a different variable QK_ceilingPrio_, which represents the ceiling-priority locked by the mutex. The <a class="el" href="class_q_k.html" title="QK services.">QK</a> scheduler and extended scheduler now perform an additional check to make sure that only tasks with priorities above the ceiling can run. To avoid that additional overhead, the user can define the macro QK_NO_MUTEX, which eliminates the <a class="el" href="class_q_k.html" title="QK services.">QK</a> mutex API and eliminates the additional tests in the <a class="el" href="class_q_k.html" title="QK services.">QK</a> schedulers.</p>
<p>This maintenance release does not change the QP/C++ API in any way, so the release has NO IMPACT on the QP/C++ applications.</p>
<p>The main changes in QP v4.0.03 with respect to earlier version are as follows:</p>
<ul>
<li>in <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> file, made the <a class="el" href="class_q_k.html" title="QK services.">QK</a> mutex API only visible when the macro QK_NO_MUTEX is *not* defined.</li>
<li>in <a class="el" href="qk__pkg_8h.html" title="Internal (package scope) QK/C interface.">qk_pkg.h</a> file, added the QK_ceilingPrio_ external declaration when the macro QK_NO_MUTEX is not defined.</li>
<li>in <a class="el" href="qk__mutex_8cpp.html" title="QK::mutexLock()/QK::mutexUnlock() implementation.">qk_mutex.cpp</a> file, changed priority-ceiling mutex implementation to use the QK_ceilingPrio_ instead of QK_currPrio_. Also, added compiler error when the macro QK_NO_MUTEX is definedthis and this file is included in the build.</li>
<li>in <a class="el" href="qk__sched_8cpp.html" title="QK_schedule_() implementation.">qk_sched.cpp</a> file added testing priority against the QK_ceilingPrio_, when the macro QK_NO_MUTEX is not defined.</li>
<li>in <a class="el" href="qk__ext_8cpp.html" title="QK_scheduleExt_() implementation.">qk_ext.cpp</a> file added testing priority against the QK_ceilingPrio_, when the macro QK_NO_MUTEX is not defined.</li>
</ul>
<h2><a class="anchor" id="qpcpp_4_0_02"></a>
Version 4.0.02 (Product) Release date: Nov 15, 2008</h2>
<p>This maintenance release does not change the QP/C API in any way, so the release has NO IMPACT on the QP/C++ applications.</p>
<p>The main changes in QP v4.0.02 with respect to earlier version are as follows:</p>
<ul>
<li>in <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> file, added comments to macros <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> and <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a> to suppress the PC-lint warining about using the comma-operator (MISRA rule 42).</li>
<li>in <a class="el" href="qhsm__in_8cpp.html" title="QHsm::isIn() implementation.">qhsm_in.cpp</a> file, fixed a bug in the <a class="el" href="class_q_hsm.html#ac04495c0c6ea4802b3f4891759b08ab1" title="Tests if a given state is part of the current active state configuratioin.">QHsm::isIn()</a> function. - fixed a bug in tunnel.cpp file ("Fly 'n' Shoot" game). The constant event HIT_WALL was not declared static.</li>
</ul>
<h2><a class="anchor" id="qpcpp_4_0_01"></a>
Version 4.0.01 (Product) Release date: June 09, 2008</h2>
<p>This maintenace release is made to allow using <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> software tracing with the GNU compiler for AVR (WinAVR). Specifically, the output of the strings residing in ROM has been fixed.</p>
<p>This maintenance release does not change the QP/C++ API in any way, so the release has NO IMPACT on the QP/C++ applications.</p>
<p>The main changes in QP v4.0.01 with respect to earlier version are as follows:</p>
<ul>
<li>in <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a> file, updated the function <a class="el" href="class_q_s.html#ad49c7e37c4f24480b063b76c1cc048a6" title="Output zero-terminated ASCII string element allocated in ROM without format information.">QS::str_ROM_()</a>.</li>
<li>in <a class="el" href="qs__str_8cpp.html" title="QS::str() and QS::str_ROM() implementation.">qs_str.cpp</a> file, updated the function <a class="el" href="class_q_s.html#a5d46ccdd8c2cfa3e1a0cc66400731bf7" title="Output zero-terminated ASCII string element allocated in ROM with format information.">QS::str_ROM()</a>.</li>
<li>in <a class="el" href="qvanilla_8cpp.html" title="&quot;vanilla&quot; cooperative kernel, QActive::start(), QActive::stop(), and QF::run() implementati...">qvanilla.cpp</a> file, funciton <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>, declared the temporary variables as static to save stack space, because <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> never returns and is not reentrant.</li>
</ul>
<h2><a class="anchor" id="qpcpp_4_0_00"></a>
Version 4.0.00 (Product) Release date: Apr 07, 2008</h2>
<p>This milestone release is made for the book <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>. The book describes in great detail this new release. The older "QP Programmer's Manual" is now phased out and is replaced with this hyper-linked <a class="el" href="index.html#main_page">QP/C++ Reference Manual</a>, which provides very detailed, easily searchable reference to the software. The book <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> provies in-depth discussion of the relevant concepts as well as the design study of QP v4.0.</p>
<p>The main changes in QP v4.0 with respect to earlier versions are as follows:</p>
<ul>
<li>the coding techniques for hierarchical state machines (HSMs) and the simpler finite state machines (FSMs) have changed. While the changes are quite simple, the backward compatibility with <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> 3.x has been broken, meaning that some manual changes to the state machines implemented with earlier versions are necessary. Please refer to the "QP/C++ Tutorial" Section <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a> for more information about coding state machines with <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> 4.x.<ul>
<li>The main change is the signature of a state-handler function, which now returns simply a byte. This return type (typedef'ed as QState) is the status of the event-handling that the state handler conveys to the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor.</li>
<li>The macro <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> must now always follow the return statement.</li>
<li>The new macro <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a> designates the superstate of the given state. Again, this macro must follow the return statement.</li>
<li>Then two new macros <a class="el" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED()</a> and <a class="el" href="qep_8h.html#a4b1bc93dc610e97650f324dc7901cd86" title="The macro returned from a non-hierarchical state-handler function when it ignores (does not handle) t...">Q_IGNORED()</a> have been added to return the status of event handled and event ignored, respectively.</li>
</ul>
</li>
</ul>
<ul>
<li>all callback functions are now consistently called <code>XXX_onYYY()</code> or <code>XXX::onYYY()</code>:<ul>
<li>Q_assert_handler() is now <a class="el" href="qassert_8h.html#a4b763b7acf73342465ab91d5752f1b14">Q_onAssert()</a></li>
<li>QF::start() is now <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2" title="Startup QF callback.">QF::onStartup()</a></li>
<li>QF::cleanup() is now <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback.">QF::onCleanup()</a></li>
</ul>
</li>
</ul>
<ul>
<li>the new header file <a class="el" href="qevent_8h.html" title="QEvent class and basic macros used by all QP components.">qevent.h</a> has been broken off the <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> header file. <a class="el" href="qevent_8h.html" title="QEvent class and basic macros used by all QP components.">qevent.h</a> contains the <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> class and other basic facilities used in the whole QP. This new file allows easier replacement of the entire <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> event processor with custom event processors, if you wish do so.</li>
<li>the macro QEP_SIGNAL_SIZE is renamed to <a class="el" href="qevent_8h.html#afdaa94c40e947b0340b4259eddce3561" title="The size (in bytes) of the signal of an event. Valid values: 1, 2, or 4; default 1.">Q_SIGNAL_SIZE</a>.</li>
<li>the data type QSTATE is now deprecated. Please use <a class="el" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a>.</li>
<li>the #QF_FSM_ACTIVE macro is now deprecated. Instead, please define <a class="el" href="qf_8h.html#a693fe2fdd4b701be0836f7cad7ee7e45" title="The macro defining the base class for QActive.">QF_ACTIVE_SUPER_</a> to the base class of <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> and <a class="el" href="qf_8h.html#a63b8eade38e9ed1bd9e34cf10ceb718b" title="The argument of the base class&#39; constructor.">QF_ACTIVE_STATE_</a> to the data type represented state. By default, these macros are defined to use the <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> base class from the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> hierarchical event processor, but you can replace the event processor, if you wish.</li>
<li>the internal macro QACTIVE_OSOBJECT_WAIT_() is now <a class="el" href="qk_8h.html#ae2426ed9b8543cbbccde98023d7773a7" title="Platform-dependent macro defining how QF should block the calling task when the QF native queue is em...">QACTIVE_EQUEUE_WAIT_()</a>.</li>
<li>the internal macro QACTIVE_OSOBJECT_SIGNAL_() is now <a class="el" href="qk_8h.html#ad4ad4a29e36b9ad8e2aff0e7074c2a68" title="Platform-dependent macro defining how QF should signal the active object task that an event has just ...">QACTIVE_EQUEUE_SIGNAL_()</a>.</li>
<li>the internal macro QACTIVE_OSOBJECT_ONIDLE_() is now <a class="el" href="qk_8h.html#a61cb9dfde96112710d74f08620875427" title="Platform-dependent macro defining the action QF should take when the native QF event queue becomes em...">QACTIVE_EQUEUE_ONEMPTY_()</a>.</li>
<li>the data mebers QActive::m_osObject and QActive::m_thread are now present only if the macros #QF_OS_OBJECT_TYPE and #QF_THREAD_TYPE are defined.</li>
<li>the ::QPSet class has been renamed to <a class="el" href="class_q_p_set64.html" title="Priority Set of up to 64 elements for building various schedulers, but also useful as a general set o...">QPSet64</a>.</li>
<li>the QPSet::hasElements() has been renamed <a class="el" href="class_q_p_set8.html#a9ba7b552623fb6567c75224f45c55a44" title="the function evaluates to TRUE if the priority set has elements, which means that some active objects...">QPSet64::notEmpty()</a></li>
<li>the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> software tracing is now better integrated with all QP components. You no longer need to explicitly include <a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a>, because it is automatically included when you define the macro #Q_SPY. Also the file <a class="el" href="qs__dummy_8h.html" title="Dummy definitions of the QS macros that avoid code generation from the QS instrumentation.">qs_dummy.h</a> is included automatically when the macro #Q_SPY is <b>not</b> defined.</li>
<li>the new header file <a class="el" href="qvanilla_8h.html" title="platform-independent interface to the cooperative &quot;vanilla&quot; kernel.">qvanilla.h</a> now replaces the file qsched.h.</li>
<li>the macros QF_SCHED_LOCK() and QF_SCHED_UNLOCK() are now obsolete.</li>
<li>the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queues (both the active object event queues and the "raw" thread-safe queues) are slightly more efficient by counting down the <code>head</code> and <code>tail</code> pointers rather than up. This leads to wrap-around at zero, which is easier (faster) to test than any other wrap-around point. Also the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queues maintain the minimum of the free events in the queue rather the maximum of used events.</li>
<li>the data member of QEQueue::nTot class is removed.</li>
<li>the <a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317" title="Publish event to the framework.">QF::publish()</a> function has been re-written so that <a class="el" href="class_q_f.html" title="QF services.">QF</a> no does <b>not need to lock the scheduler</b>. The <a class="el" href="class_q_f.html#a35ad8ba7e1f1bce525b80d5156465317" title="Publish event to the framework.">QF::publish()</a> function posts events to active objects with scheduler unlocked starting from the highest-priority active objects. However, the event is protected from inadvertent recycling by incrementing its reference counter before the publish operation. After the event is posted to all subscribers, the garbage collector <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a> is called to decrement the reference counter and recycle the event, if necessary.</li>
<li>the qf_run.cpp file is obsolete. The <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a> function for the cooperative "vanilla" kernel is now implemented in the file <a class="el" href="qvanilla_8cpp.html" title="&quot;vanilla&quot; cooperative kernel, QActive::start(), QActive::stop(), and QF::run() implementati...">qvanilla.cpp</a>.</li>
<li>the <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a> function has been rewritten to allow calling <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a> from the task context as well as from the interrupt context. The nested critical section around <a class="el" href="class_q_f.html#a1e53786c3f398cf9c37d5a02ead5a79b" title="Processes all armed time events at every clock tick.">QF::tick()</a> is no longer needed when it is called from the task level. Among others, this re-design <b>eliminates the need for the recursive</b> mutex in the POSIX <a class="el" href="class_q_f.html" title="QF services.">QF</a> port.</li>
<li>the <a class="el" href="class_q_m_pool.html#aa669322b615cf7d2e75a61396eca802e" title="Initializes the native QF event pool.">QMPool::init()</a> function has been re-designed to optimally align the memory buffer in a portable and platform-independent way. This should bring some performance improvements on some CPUs (e.g., 80x86).</li>
<li>the extended <a class="el" href="class_q_k.html" title="QK services.">QK</a> scheduler has been re-designed to save stack space. The extended context (e.g., coprocessor registers) are no longer saved on the precious stack, but rather in the active object.</li>
<li>a bug has been fixed in handling of Thread-Local Storage (TLS) in the <a class="el" href="class_q_k.html" title="QK services.">QK</a> scheduler and extended scheduler.</li>
</ul>
<ul>
<li>the -q (quiet) flag has been added to the QSPY host application.</li>
<li>the support for two new compilers for Windows has been added for the QSPY host application. The application can now be build with the MinGW GNU compiler for Windows as well as the Microsoft Visual C++ 2005.</li>
</ul>
<ul>
<li>the QP port to Linux has been improved by eliminating the need for recursive P-Thread mutex.</li>
</ul>
<ul>
<li>the QP port to MicroC/OS-II has been upgraded to the latest version 2.86.</li>
</ul>
<ul>
<li>all examples in the standard QP distribution have been cleaned up and updated to the latest QP API changes.</li>
<li>all examples that use <a class="el" href="class_q_f.html" title="QF services.">QF</a> now contain the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> software tracing support.</li>
</ul>
<h2><a class="anchor" id="qpcpp_3_4_01"></a>
Version 3.4.01 (Product)</h2>
<p>Release date: Sep 25, 2007</p>
<p>This product release adds the backward-compatibility layer so that previous QP/C++ ports continue to work with the new version.</p>
<p>This product release also comes with the updated "QP Programmer's Manual", which now includes the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> target component and the QSpy host application.</p>
<h2><a class="anchor" id="qpcpp_3_4_00"></a>
Version 3.4.00 (Beta)</h2>
<p>Release date: Sep 03, 2007</p>
<p>This release brings several changes with the overall goal of simplifying and improving consistency across the whole QP family of frameworks (QP/C, QP/C++, and QP-nano).</p>
<p>The main changes are made to the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> component. The "static transition
optimization" has been removed altogether. This simplifies significantly the state machine structure (which now contains just the currently active state). Also, the efficiency is improved for processing the dynamic transitions and the stack usage is lower. This change brings the QEP/C++ implementation much closer to QEP-nano.</p>
<p>The other big change in this release is including the Quantum Spy (<a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a>) component in the distribution. Previously, the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> component was available only under the commercial licensing. It is now open source, just as the rest of QP.</p>
<p>In, the QF/C++ component, the QTimerEvt::publishIn() and QTimeEvt::publishEvery() have been removed, because they introduced a coupling between time events and publish-subscribe. This is undesirable for projects that do not want to include the publish-subscribe facilty.</p>
<p>Finally, the revision history for individual QP/C++ components has been moved from the header files and is now consolidated in the header file doxygen/qpcpp_rev.h.</p>
<p>The updated "QP Programmer's Manual" is in the works...</p>
<h2><a class="anchor" id="qpcpp_3_3_00"></a>
Version 3.3.00 (Product)</h2>
<p>Release date: Jan 23, 2007</p>
<p>The main change in this release is removing #include &lt;stdint.h&gt; from the <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> header file. This has been done becasue vast majority of embedded compilers for small MCUs actually do not provide the C-99 Standard header file &lt;stdint.h&gt;. Worse, compilers such as Freescale HC(S)08 C/C++ compiler will not include &lt;stdint.h&gt; unless it's in the compilers's include directory, even though the "stdint.h" file might be in the compiler include path.</p>
<p>Removing the "#include &lt;stdint.h&gt;" from <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> header file allows more flexibility in the way the standard exact-width integer types are defined. For compilers that do not provide the &lt;stdint.h&gt; file, you provide the typedef's in the <a class="el" href="qep__port_8h.html" title="QEP/C port to QK for a &quot;generic&quot; C compiler.">qep_port.h</a> file before including <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a>. For compilers that do provide the &lt;stdint.h&gt; header file, you simply include this file in the <a class="el" href="qep__port_8h.html" title="QEP/C port to QK for a &quot;generic&quot; C compiler.">qep_port.h</a> header file before including <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a>.</p>
<p>The changes in release 3.3.00 have impact on all QP ports, because you need to modify the <a class="el" href="qep__port_8h.html" title="QEP/C port to QK for a &quot;generic&quot; C compiler.">qep_port.h</a> file in all these ports.</p>
<p>The other significant change in this release is adding the macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for all constant objects allocated in ROM. The <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> macro has been added for the compilers like Freescale HC(S)08, which require far pointers to access the objects in ROM. Please note that specifying the pointer size for accessing a ROM objects is syntactically different than specifying that the object is allocated in ROM (see macro <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM.">Q_ROM</a>).</p>
<p><a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> is now better integrated with the rest of QP. This is achieved by using the QP macros <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM.">Q_ROM</a>, <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a>, <a class="el" href="qf__port_8h.html#a243406ad5c97d8a56625f0cd3bb41c67" title="Define the type of the interrupt lock key.">QF_INT_KEY_TYPE</a>, <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a>, and <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>. By simply including the header file "qf_port.h" before "qs.h" in the "qs_port.h" include, you no longer need to manually ensure that <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> implements the same policies as the rest of QP. This change still allows using <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> standalone (without any other QP components), but then the QP macros must be explicitly defined in the <a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a> header file. Also the macro #QS_ROM_VAR has been added for all constant objects allocated in ROM (see also macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> added to <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a>). The #QS_ROM_VAR macro has been added for the compilers like Freescale HC(S)08, which require far pointers to access the objects in ROM. Please note that specifying the pointer size for accessing a ROM objects is syntactically different than specifying that the object is allocated in ROM (see macro <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM.">Q_ROM</a>).</p>
<p>Finally, in release 3.3.00 the build strategy for QP ports has been simplified as well. Instead of separate Makefile for every QP component, such as <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a>, <a class="el" href="class_q_f.html" title="QF services.">QF</a>, <a class="el" href="class_q_k.html" title="QK services.">QK</a>, and <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a>, not the "ports" directory contains a batch file "make.bat" that builds all the libraries at once.</p>
<ol type="1">
<li>in file <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> removed "#include &lt;stdint.h&gt;".</li>
<li>in file <a class="el" href="qassert_8h.html" title="Customizable QP assertions.">qassert.h</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> added default empty definitions and Doxygen comments for macros <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM.">Q_ROM</a> and <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a>.</li>
<li>in file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file qf.cpp added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> added Q_ROM_VAR to the signature of <a class="el" href="class_q_e_p.html#a6ebe00c8d3227c7421885eee6d626f06" title="get the current QEP version number string">QEP::getVersion()</a>.</li>
<li>in file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> changed the version number to "3.3.00".</li>
<li>in file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>in file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> removed method QF::getTime() and deleted external variable QF::tickCtr.</li>
<li>deleted obsolete file qa_fifo_.cpp</li>
<li>deleted obsolete file qa_lifo_.cpp</li>
<li>deleted obsolete file qf_time.cpp</li>
<li>in file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> added Q_ROM_VAR to the signature of <a class="el" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e" title="Returns the QF version.">QF::getVersion()</a></li>
<li>in file <a class="el" href="qf__log2_8cpp.html" title="QF_log2Lkup[] implementation.">qf_log2.cpp</a> added Q_ROM_VAR to the definition of the lookup.</li>
<li>in file <a class="el" href="qf__pwr2_8cpp.html" title="QF_pwr2Lkup[], QF_invPwr2Lkup[], and QF_div8Lkup[] definitions.">qf_pwr2.cpp</a> added Q_ROM_VAR to the definition of the lookups.</li>
<li>in file <a class="el" href="qf__tick_8cpp.html" title="QF::tick() implementation.">qf_tick.cpp</a> removed incrementing QF::tickCtr.</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> updated version number to 3.3.00</li>
<li>Updated the "QP Programmer's Manaul" to Revision E</li>
<li>in file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> added macro <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> added <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> to the signature of <a class="el" href="class_q_k.html#a58ede2629c097b98c54f2398f07f2a68" title="get the current QK version number string">QK::getVersion()</a>.</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> updated version number to 3.3.00</li>
<li>in file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added macro #QS_ROM_VAR for objects allocated in ROM and to signatures of functions accessing these objects.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added default definitions of the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> macros <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3" title="Macro to specify compiler-specific directive for placing a constant object in ROM.">Q_ROM</a>, <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a>, and Q_ROM_BYTE.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added declaration of QS_tickCtr_.</li>
<li>In file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> added <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> to the signature of <a class="el" href="class_q_s.html#adf99871ede21583a1186cbb277379006" title="Get the current version of QS.">QS::getVersion()</a>.</li>
<li>In file <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a> added <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> to the signature of <a class="el" href="class_q_s.html#ad49c7e37c4f24480b063b76c1cc048a6" title="Output zero-terminated ASCII string element allocated in ROM without format information.">QS::str_ROM_()</a>.</li>
<li>In file <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a> added definition of QS_tickCtr_.</li>
<li>In file <a class="el" href="qs__str_8cpp.html" title="QS::str() and QS::str_ROM() implementation.">qs_str.cpp</a> added <a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283" title="Macro to specify compiler-specific directive for accessing a constant object in ROM.">Q_ROM_VAR</a> to the signature of <a class="el" href="class_q_s.html#a5d46ccdd8c2cfa3e1a0cc66400731bf7" title="Output zero-terminated ASCII string element allocated in ROM with format information.">QS::str_ROM()</a>.</li>
<li>In file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> updated version number to 3.3.00</li>
<li>Updated the "QP Programmer's Manaul" to Revision E</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_05"></a>
Version 3.2.05</h2>
<p>Release date: Dec 08, 2006</p>
<p>This <a class="el" href="class_q_f.html" title="QF services.">QF</a> release rolls back the changes made to the reference-counting policy. The reference count of a dynamic event is incremented when the event is posted, but is NOT decremented when the event is retreived from the queue. The reference count is decremented only later, in the garbage collector (<a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a>).</p>
<p>This release adds direct support for event deferral (the "Deferred Event" state pattern) through methods <a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5" title="Defer an event to a given separate event queue.">QActive::defer()</a> and <a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a>.</p>
<ol type="1">
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added methods <a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5" title="Defer an event to a given separate event queue.">QActive::defer()</a> and <a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a>.</li>
<li>In file <a class="el" href="qa__get___8cpp.html" title="QActive::get_() and QF::getQueueMargin() definitions.">qa_get_.cpp</a> removed decrementing the reference count of a dynamic event.</li>
<li>In file <a class="el" href="qeq__get_8cpp.html" title="QEQueue::get() implementation.">qeq_get.cpp</a> removed decrementing the reference count of a dynamic event.</li>
<li>In file <a class="el" href="qf__gc_8cpp.html" title="QF::gc() implementation.">qf_gc.cpp</a> restored decrementing of the reference count of a dynamic event.</li>
<li>Added new file <a class="el" href="qa__defer_8cpp.html" title="QActive::defer() and QActive::recall() implementation.">qa_defer.cpp</a> that implements <a class="el" href="class_q_active.html#a2b60c62e712768b6fadfa1fd75f910e5" title="Defer an event to a given separate event queue.">QActive::defer()</a> and <a class="el" href="class_q_active.html#a0ec00766be634a8e71a380a115ecfbaa" title="Recall a deferred event from a given event queue.">QActive::recall()</a>.</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> updated version number to 3.2.05</li>
<li>Updated the "QP Programmer's Manaul" to Revision D</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_04"></a>
Version 3.2.04  (Beta)</h2>
<p>Release date: Dec 01, 2006</p>
<p>This <a class="el" href="class_q_f.html" title="QF services.">QF</a> release changes the internal policy of reference-counting for dynamic events. The reference count of a dynamic event is now incremented when the event is posted to a queue and decremented when the event is later retreived from the queue. This policy pertains to both active object queues and native <a class="el" href="class_q_f.html" title="QF services.">QF</a> thread-safe queues (<a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class.">QEQueue</a>).</p>
<p>Previously, the reference count of a dynamic event was not decremented upon retreival of the event from the event queue, but rather in the garbage collector (<a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event.">QF::gc()</a>).</p>
<p>This <a class="el" href="class_q_k.html" title="QK services.">QK</a> release adds two new features in <a class="el" href="class_q_k.html" title="QK services.">QK</a>. The first feature added is the extended context switch for CPUs with co-processors, such as the x87 FPU accompanying the x86 CPU. As a fully- preemptive kernel, <a class="el" href="class_q_k.html" title="QK services.">QK</a> needs to save and restore the context of the co- processor accrosss the asynchronous preemption. This <a class="el" href="class_q_k.html" title="QK services.">QK</a> release adds a generic mechanism for saving and restoring extened context in the extended scheduler (QK_scheduleExt_()), which is used only at the exit from the interrupts (asynchronous preemptions).</p>
<p>The second feature added is the Thread-Local Storage (TLS) for reentrant libraries, such as the NewLib. This feature allows assigning per-thread memory and providing a hook (callback) activated at every context switch.</p>
<ol type="1">
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> eliminated methods QActive::postFIFO_() and QActive::postLIFO_().</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> promoted method <a class="el" href="class_q_active.html#a29d494a0802145fdaf510ccc89c61dce" title="Get an event from the event queue of an active object.">QActive::get_()</a> to the public scope to make it available to various thread-run routines.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> promoted method <a class="el" href="class_q_active.html#a36aa82f457ec53ab04b3f6b69a67f72c" title="Un-subscribes from the delivery of all signals to the active object.">QActive::unsubscribeAll()</a> to the public scope to make it available to various thread-run routines.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> promoted method <a class="el" href="class_q_f.html#a0032e774fcf6293d2136e960fcc48528" title="Remove the active object from the framework.">QF::remove_()</a> to the public scope to make it available to various thread-run routines.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added friendship between class <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> and QK_scheduleExt_() and QK_isrExit_().</li>
<li>In file <a class="el" href="qa__fifo_8cpp.html" title="QActive::postFIFO() implementation.">qa_fifo.cpp</a> changed the implementation of <a class="el" href="class_q_active.html#a46f02154787a4f0f0ac91638251da82a" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive::postFIFO()</a> to represent the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue of an active object.</li>
<li>In file qa_fifo_.cpp removed the implementation of QActive::postFIFO_() and declared the file obsolete (will be removed in future releases).</li>
<li>In file <a class="el" href="qa__lifo_8cpp.html" title="QActive::postLIFO() implementation.">qa_lifo.cpp</a> changed the implementation of <a class="el" href="class_q_active.html#a6c2deb168c17567ab6bbc2178d67878d" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive::postLIFO()</a> to represent the native <a class="el" href="class_q_f.html" title="QF services.">QF</a> event queue of an active object.</li>
<li>In file qa_lifo_.cpp removed the implementation of QActive::postLIFO_() and declared the file obsolete (will be removed in future releases).</li>
<li>In file <a class="el" href="qa__get___8cpp.html" title="QActive::get_() and QF::getQueueMargin() definitions.">qa_get_.cpp</a> added decrementing the reference count of a dynamic event.</li>
<li>In file <a class="el" href="qf__gc_8cpp.html" title="QF::gc() implementation.">qf_gc.cpp</a> removed decrementing of the reference count of a dynamic event. Also changed the test for recycling an event (reference count of zero).</li>
<li>In file <a class="el" href="qf__pspub_8cpp.html" title="QF::publish() implementation.">qf_pspub.cpp</a> removed incrementing the reference count of a dynamic event.</li>
<li>Removed all uses of the macros #QACTIVE_POST_FIFO_, #QACTIVE_POST_LIFO_ and QACTIVE_GET_. These macros are made now obsolete.</li>
<li>In file qsched.h removed definitions of the obsolete macros #QACTIVE_POST_FIFO_, #QACTIVE_POST_LIFO_, and QACTIVE_GET_.</li>
<li>In file <a class="el" href="qf__pspub_8cpp.html" title="QF::publish() implementation.">qf_pspub.cpp</a> replaced the macro QACTIVE_POST_FIFO_() with the direct method invocation active_[p]-&gt;postFIFO(e).</li>
<li>In file <a class="el" href="qf__tick_8cpp.html" title="QF::tick() implementation.">qf_tick.cpp</a> replaced the macro QACTIVE_POST_FIFO_() with the direct method invocation active_[p]-&gt;postFIFO(e).</li>
<li>In file <a class="el" href="qa__run_8cpp.html" title="QActive::run() implementation.">qa_run.cpp</a> replaced the macro QACTIVE_POST_GET_() with the direct method invocation get_().</li>
<li>Changed the uC/OS-II port to reflect new policy of handling reference counters inside the dynamic events. Also removed files <a class="el" href="qa__fifo_8cpp.html" title="QActive::postFIFO() implementation.">qa_fifo.cpp</a> and <a class="el" href="qa__lifo_8cpp.html" title="QActive::postLIFO() implementation.">qa_lifo.cpp</a> from the uC/OS-II build.</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> updated version number to 3.2.04</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> updated revision history and added the prototype for the extended scheduler QK_scheduleExt_(). This scheduler implements the generic extended context via macros #QK_EXT_TYPE, <a class="el" href="qk__port_8h.html#a8dc2ef090cbfdb8068e02be7af74a7a7" title="Define the method for saving the extended context (e.g., the context of a floating-point co-processor...">QK_EXT_SAVE</a>, and <a class="el" href="qk__port_8h.html#a7300efd5716c71f33e1a0a17ac4a95ed" title="Define the method for restoring the extended context (e.g., the context of a floating-point co-proces...">QK_EXT_RESTORE</a>.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> removed definitions of the obsolete macros #QACTIVE_POST_FIFO_, #QACTIVE_POST_LIFO_, and QACTIVE_GET_.</li>
<li>In file <a class="el" href="qk__sched_8cpp.html" title="QK_schedule_() implementation.">qk_sched.cpp</a> added logic for handling the TLS via the macro <a class="el" href="qk__port_8h.html#a0fff98f5737d46ce7a2228e38486c5ba" title="Define the method for switching the Thread-Local-Storage for for a given thread.">QK_TLS</a>.</li>
<li>Added new file <a class="el" href="qk__ext_8cpp.html" title="QK_scheduleExt_() implementation.">qk_ext.cpp</a> with the definition of the extended scheduler QK_scheduleExt_().</li>
<li>Added the file <a class="el" href="qk__ext_8cpp.html" title="QK_scheduleExt_() implementation.">qk_ext.cpp</a> to the Makefile for <a class="el" href="class_q_k.html" title="QK services.">QK</a> port to 80x86 with Turbo C++ 1.01.</li>
<li>Extended the <a class="el" href="class_q_k.html" title="QK services.">QK</a> port to 80x86 with Turbo C++ 1.01 to handle the x87 FPU context.</li>
<li>Extended the QDPP example for <a class="el" href="class_q_k.html" title="QK services.">QK</a> with Turbo C++ 1.01 to demonstrate threads that use the FPU and require the extended context switch.</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> updated version number to 3.2.04</li>
<li>Updated the "QP Programmer's Manaul" to Revision C</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_03"></a>
Version 3.2.03 (Product)</h2>
<p>Release date: Nov 15, 2006</p>
<p>The main purpose of this release is to adapt the code to the shortcomings of the gcc compiler for handling data in program ROM for Harvard architecture CPUs, such as the Atmel's AVR or the 8051. In such machines, the data space (RAM) and program space (ROM) are accessed with different instructions. The gcc compiler does not automatically synthesize the correct code for accessing data placed in the program ROM, even though __attribute__((__progmem__)) is used. The workaround for the gcc is to add special assembly instructions to transfer the data from the program space to the data space. This version of QP-nano adds macros for each data element allocated to the program space (delcared with the Q_ROM attribute) Please note that commercial compilers, such as IAR, handle data allocated in the program space (ROM) correctly and do not need any workarounds.</p>
<p>This release also fixes a few minor inconsistencies in the code (see the list below):</p>
<ol type="1">
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added default definition of macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a></li>
<li>In file qf_set.h added macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a> to access the lookup tables allocated in ROM (several places).</li>
<li>In file qf_sched.h changed types QF_OS_OBJECT_TYPE and QF_THREAD_TYPE to uint8_t from int8_t</li>
<li>In file <a class="el" href="qs__dummy_8h.html" title="Dummy definitions of the QS macros that avoid code generation from the QS instrumentation.">qs_dummy.h</a> added dummy definitions of some missing <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> macros</li>
<li>In file <a class="el" href="qa__sub_8cpp.html" title="QActive::subscribe() implementation.">qa_sub.cpp</a> added macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a> to access the lookup tables allocated in ROM (several places).</li>
<li>In file <a class="el" href="qa__usub_8cpp.html" title="QActive::unsubscribe() implementation.">qa_usub.cpp</a> added macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a> to access the lookup tables allocated in ROM (several places).</li>
<li>In file qf_usuba.cpp added macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a> to access the lookup tables allocated in ROM (several places).</li>
<li>In file <a class="el" href="qf__pspub_8cpp.html" title="QF::publish() implementation.">qf_pspub.cpp</a> added macro <a class="el" href="qs__pkg_8h.html#aabc3bb6d854fe3a71937f0a09764f8f7" title="Macro to access a byte allocated in ROM.">Q_ROM_BYTE</a> to access the lookup tables allocated in ROM (several places).</li>
<li>In file <a class="el" href="qf__tick_8cpp.html" title="QF::tick() implementation.">qf_tick.cpp</a> replaced QF_tickCtr_ with <a class="el" href="class_q_s.html#ac4cb901388b40cb908baea56288b2bb5" title="tick counter for the QS_QF_TICK record">QS::tickCtr_</a>. allocated in ROM (several places).</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> updated version number to 3.2.03</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_02"></a>
Version 3.2.02 (Product)</h2>
<p>Release date: Oct 30, 2006<br/>
</p>
<ol type="1">
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> replaced macro Q_ROM with QS_ROM</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added methods <a class="el" href="class_q_s.html#ad49c7e37c4f24480b063b76c1cc048a6" title="Output zero-terminated ASCII string element allocated in ROM without format information.">QS::str_ROM_()</a> and <a class="el" href="class_q_s.html#a5d46ccdd8c2cfa3e1a0cc66400731bf7" title="Output zero-terminated ASCII string element allocated in ROM with format information.">QS::str_ROM()</a></li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added macros <a class="el" href="qs_8h.html#a9e76bdf4e360917f4307d378034dfc42" title="Internal QS macro to output a zero-terminated ASCII string allocated in ROM data element.">QS_STR_ROM_()</a> and <a class="el" href="qs_8h.html#a7f6f1126a11ee04ae6e3a3d6dd00eba3" title="Output formatted zero-terminated ASCII string from ROM to the QS record.">QS_STR_ROM()</a></li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> modified macros QS_???_DICTIONARY() to use ROM strings</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> included <a class="el" href="qs__dummy_8h.html" title="Dummy definitions of the QS macros that avoid code generation from the QS instrumentation.">qs_dummy.h</a> instead of the dummy definitions of the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> macros</li>
<li>In file <a class="el" href="qs__pkg_8h.html" title="Internal (package scope) QS/C++ interface.">qs_pkg.h</a> added #ifndef Q_SPY before definition of macro Q_SPY</li>
<li>In file <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a> added definition of the function <a class="el" href="class_q_s.html#ad49c7e37c4f24480b063b76c1cc048a6" title="Output zero-terminated ASCII string element allocated in ROM without format information.">QS::str_ROM_()</a></li>
<li>In file <a class="el" href="qs__str_8cpp.html" title="QS::str() and QS::str_ROM() implementation.">qs_str.cpp</a> added definition of the function <a class="el" href="class_q_s.html#a5d46ccdd8c2cfa3e1a0cc66400731bf7" title="Output zero-terminated ASCII string element allocated in ROM with format information.">QS::str_ROM()</a></li>
<li>In file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> updated version number to 3.2.02</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_01"></a>
Version 3.2.01 (Product)</h2>
<p>Release date: Sep 01, 2006</p>
<ol type="1">
<li>In file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> updated version number to 3.2.01</li>
<li>Added makefiles for building ports of all QP/C++ libraries at once.</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> updated version number to 3.2.01</li>
<li>Added makefiles for building ports of all QP/C++ libraries at once.</li>
<li>Created the consolidated manual "QP/C++ Programmer's Manual".</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> updated version number to 3.2.01</li>
<li>Added makefiles for building ports of all QP/C++ libraries at once.</li>
<li>Created the consolidated manual "QP/C++ Programmer's Manual".</li>
<li>In file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> updated version number to 3.2.01</li>
<li>In file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>In file <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>In file <a class="el" href="qs__str_8cpp.html" title="QS::str() and QS::str_ROM() implementation.">qs_str.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>In file <a class="el" href="qs__mem_8cpp.html" title="QS::mem() implementation.">qs_mem.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>In file <a class="el" href="qs__f32_8cpp.html" title="QS::f32() implementation.">qs_f32.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>In file <a class="el" href="qs__f64_8cpp.html" title="QS::f64() implementation.">qs_f64.cpp</a> removed superfluous semicolons after QS_INSERT...()</li>
<li>Added makefiles for building ports of all QP/C++ libraries at once.</li>
<li>Created the consolidated manual "QP/C++ Programmer's Manual".</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_2_00"></a>
Version 3.2.00 (Product)</h2>
<p>Release date: Aug 07, 2006</p>
<ol type="1">
<li>In file <a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a> added the default definition of Q_ROM in case it's not defined by the user.</li>
<li>In file <a class="el" href="qassert_8h.html" title="Customizable QP assertions.">qassert.h</a> added the macro Q_ROM to allocate constant strings to ROM.</li>
<li>In file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> updated version number to 3.2.00 # Updated the "QEP/C++ Programmer's Manual".</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added function QF_stop() to be called from the application code to stop the framework.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added callback function QF_cleanup() to be called from the <a class="el" href="class_q_f.html" title="QF services.">QF</a> port to cleanup before exiting to the OS.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> deprecated the function QF_exit().</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> changed the semantics of the QF::onIdle() callback. This callback is now invoked with interrupts LOCKED from the non-preemptive scheduler used in the "vanilla" <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports to "bare metal" target boards.<br/>
 <br/>
 The modification changes the responsibilities of QF::onIdle(), which now MUST at least unlock interrupts. A failure to unlock interrupts in QF::onIdle() will leave the interrupts locked all the time and would prevent the application from running.<br/>
 <br/>
 Also, the signature of QF::onIdle() now depends on the interrupt locking policy. In case of the "save and restore interrupt status" policy, the QF::onIdle() callback takes the interrupt lock key as parameter (to be able to unlock the interrups correctly).</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> used the macro Q_ROM to allocate constant objects to ROM (<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a>). Objects allocated to ROM are: the version strings, and the lookup tables (QF::log2Lkup[], QF::pwr2Lkup[], QF::invPwr2Lkup[], and QF::div8Lkup[].</dd></dl>
</li>
<li>Added new platform-independent header file qsched.h to provide the interface to the simple non-preemptive scheduler used in the "vanilla" ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> to "bare metal" targets. This header file is only applicable to the "vanilla" ports.</li>
<li>Added new platform-independent implementation file qf_run.cpp to implement the simple non-preemptive scheduler used in the "vanilla" ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> to "bare metal" targets. This implementation file eliminates the need for qf_port.cpp file in the "vanilla" ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a>. Also, the qf_run.cpp module should only be placed in the <a class="el" href="class_q_f.html" title="QF services.">QF</a> library in the vanilla <a class="el" href="class_q_f.html" title="QF services.">QF</a> ports.</li>
<li>Simplified all "vanilla" ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> to use the common platform- independent implementation provided in qf_run.cpp.</li>
<li>Updated QF::onIdle() callback in all examples of "vanilla" ports of <a class="el" href="class_q_f.html" title="QF services.">QF</a> to unlock interrupts.</li>
<li>Updated the "QF/C++ Programmer's Manual".</li>
<li>in file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> added new idle callback <a class="el" href="class_q_k.html#ad7e914cd6b9893649f4446258123b3bc" title="QK idle callback (customized in BSPs for QK)">QK::onIdle()</a>, which in contrast to QF::onIdle() is invoked with interrupts unlocked.</li>
<li>in file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> removed QK_schedLock()/QK_schedUnlock() and replaced them with QK_mutexLock()/QK_mutexUnlock(), with the semantics of returning the mutex.</li>
<li>in file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> changed the definitions of macros #QF_SCHED_LOCK/ #QF_SCHED_UNLOCK to use the new <a class="el" href="class_q_k.html" title="QK services.">QK</a> mutex API.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> used the macro Q_ROM to allocate constant objects to ROM (<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a>).</dd></dl>
</li>
<li>in file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> added the typedef for QMutex.</li>
<li>in file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> replaced the callback QF::onIdle() with the new one <a class="el" href="class_q_k.html#ad7e914cd6b9893649f4446258123b3bc" title="QK idle callback (customized in BSPs for QK)">QK::onIdle()</a>.</li>
<li>removed source file qk_lock.cpp</li>
<li>added source file <a class="el" href="qk__mutex_8cpp.html" title="QK::mutexLock()/QK::mutexUnlock() implementation.">qk_mutex.cpp</a></li>
<li>in file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> changed the version number to 3.2.00</li>
<li>in all QK/C++ examples replaced callback QF::onIdle() with <a class="el" href="class_q_k.html#ad7e914cd6b9893649f4446258123b3bc" title="QK idle callback (customized in BSPs for QK)">QK::onIdle()</a></li>
<li>Updated "QK/C++ Programmer's Manual"</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> replaced QS_QK_SCHED_LOCK/UNLOCK with QS_QK_MUTEX_LOCK/ QS_QK_MUTEX_UNLOCK. Also, changed data accompanying the trace records QS_QK_MUTEX_LOCK/UNLOCK.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> used the macro Q_ROM to allocate constant objects to ROM (<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qep_8h.html" title="QEP/C++ platform-independent public interface.">qep.h</a>).</dd></dl>
</li>
<li>in file <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a> changed the version number to 3.2.00</li>
<li>Updated "QS Programmer's Manual" in PDF.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_1_06"></a>
Version 3.1.06 (Product)</h2>
<p>Release date: May 11, 2006</p>
<ol type="1">
<li>In file <a class="el" href="qk__sched_8cpp.html" title="QK_schedule_() implementation.">qk_sched.cpp</a> removed unlocking of interrupts upon exit from QK::schedule_(). Now QK_schedule_() enters and exits with interrupts LOCKED.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> modified macro QACTIVE_OSOBJECT_SIGNAL_() to always unlock the interrupts, regardless if QK_schedule_() has been called or not.</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> added unlocking interrupts after the call to QK_SCHEDULE_() in the function <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>.</li>
<li>In file qk_lock.cpp modified the function QK::schedUnlock() to always unlock the interrupts upon exit.</li>
<li>Updated licensing information.</li>
<li>Updated "QS/C++ Programmer's Manual" in PDF.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_1_03"></a>
Version 3.1.03 (Product)</h2>
<p>Release date: Feb 10, 2006</p>
<ol type="1">
<li>In file <a class="el" href="qep_8cpp.html" title="QEP_reservedEvt_ definition and QEP::getVersion() implementation.">qep.cpp</a> added the Revision History Doxygen comment, which was previously in doxygen/qp.h</li>
<li>In file <a class="el" href="qf__act_8cpp.html" title="QF::active_[], QF::getVersion(), and QF::add_()/QF::remove_() implementation.">qf_act.cpp</a> added the Revision History Doxygen comment, which was previously in doxygen/qp.h</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> augmented comment for QF_run() to cover the case when <a class="el" href="class_q_f.html" title="QF services.">QF</a> is used with <a class="el" href="class_q_k.html" title="QK services.">QK</a>.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added the extern declarations of ::QF_tickCtr_, ::QF_intLockNest, and ::QF_isrNest_, which were previously declared in <a class="el" href="qf__pkg_8h.html" title="Internal (package scope) QF/C++ interface.">qf_pkg.h</a>.</li>
<li>In file <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a> added macros <a class="el" href="qs_8h.html#adb65971a62a666603303487fd7de33a7" title="Output the interrupt lock record.">QF_QS_INT_LOCK</a>, <a class="el" href="qs_8h.html#a8ccc2c4bfb5b6f514a579dff276fa4fa" title="Output the interrupt unlock record.">QF_QS_INT_UNLOCK()</a>, <a class="el" href="qs_8h.html#a3a8b51b47686825984c8a7c1eff990ac" title="Output the interrupt entry record.">QF_QS_ISR_ENTRY</a>, and <a class="el" href="qs_8h.html#ad212a914d996105955eac8d053183900" title="Output the interrupt exit record.">QF_QS_ISR_EXIT</a>, which were previously declared in <a class="el" href="qs__port_8h.html" title="QS/C++ port for a &quot;generic&quot; C++ compiler.">qs_port.h</a>.</li>
<li>In file ports/linux/gcc/qf_port.h added extern uint8_t QF_running_.</li>
<li>In file qf/80x86/dos/tcpp101/l/qf_port.cpp replaced deprecated QPSet::hasElements() to QPSet::isEmpty().</li>
<li>In file qf/80x86/linux/gcc/qf_port.cpp added <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a></li>
<li>In file <a class="el" href="qeq__init_8cpp.html" title="QEQueue::init() implementation.">qeq_init.cpp</a> changed <a class="el" href="qs_8h.html#a1b8d4d79089735ec19915ef7ed3e2e0b" title="Output formatted object pointer to the QS record.">QS_OBJ(this)</a> to <a class="el" href="qs_8h.html#a1b8d4d79089735ec19915ef7ed3e2e0b" title="Output formatted object pointer to the QS record.">QS_OBJ(qSto)</a> to consistently refer to a queue by the ring buffer object</li>
<li>In file <a class="el" href="qf__pkg_8h.html" title="Internal (package scope) QF/C++ interface.">qf_pkg.h</a> removed extern ::QF_tickCtr_.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> removed extern QK_intLockNest_ and QK_isrNest_. These counters have been moved to <a class="el" href="class_q_f.html" title="QF services.">QF</a> and renamed in the process to QF_intLockNest_ and QF_isrNest_, respectively.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> added <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> instrumentatin to <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a> and <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a> macros for tracing interrupt locking/unlocking. The <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> interrupt locking/ unlocking instrumentation has been previously added at the <a class="el" href="class_q_k.html" title="QK services.">QK</a> port level.</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> removed macros QK_QS_INT_LOCK()/ QK_QS_INT_UNLOCK(), QK_QS_ISR_ENTRY()/ QK_QS_ISR_EXIT(). These macros have been moved to <a class="el" href="class_q_f.html" title="QF services.">QF</a> and renamed in the process to <a class="el" href="qs_8h.html#adb65971a62a666603303487fd7de33a7" title="Output the interrupt lock record.">QF_QS_INT_LOCK()</a>/ <a class="el" href="qs_8h.html#a8ccc2c4bfb5b6f514a579dff276fa4fa" title="Output the interrupt unlock record.">QF_QS_INT_UNLOCK()</a>, <a class="el" href="qs_8h.html#a3a8b51b47686825984c8a7c1eff990ac" title="Output the interrupt entry record.">QF_QS_ISR_ENTRY()</a>/ <a class="el" href="qs_8h.html#ad212a914d996105955eac8d053183900" title="Output the interrupt exit record.">QF_QS_ISR_EXIT()</a>, respectively.</li>
<li>In file ports/80x86/qk/tcpp101/l/qk_port.h simplified the definition of the macros #QK_INT_LOCK/ #QK_INT_UNLOCK to NOT contain the <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> instrumenation.</li>
<li>In file ports/80x86/qk/tcpp101/l/qk_port.h changed the definitions of <a class="el" href="qk__port_8h.html#ad3a6c9c79a8f39f1299196922e3eb6b5" title="Define the ISR entry sequence, if the compiler supports writing interrupts in C++.">QK_ISR_ENTRY</a> and <a class="el" href="qk__port_8h.html#a18f2cc4dd2d00e3d5efb593d0754a95b" title="Define the ISR exit sequence, if the compiler supports writing interrupts in C++.">QK_ISR_EXIT</a> to use <a class="el" href="qs_8h.html#a3a8b51b47686825984c8a7c1eff990ac" title="Output the interrupt entry record.">QF_QS_ISR_ENTRY</a>/ <a class="el" href="qs_8h.html#ad212a914d996105955eac8d053183900" title="Output the interrupt exit record.">QF_QS_ISR_EXIT</a>.</li>
<li>In file <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> added the Revision History Doxygen comment</li>
<li>In file <a class="el" href="qk__pkg_8h.html" title="Internal (package scope) QK/C interface.">qk_pkg.h</a> changed the definition of internal <a class="el" href="class_q_k.html" title="QK services.">QK</a> macros #QK_INT_LOCK_/ #QK_INT_UNLOCK_ to use the QS-instrumented <a class="el" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098" title="Define the interrupt locking policy.">QF_INT_LOCK</a>/ <a class="el" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186" title="Define the interrupt unlocking policy.">QF_INT_UNLOCK</a>.</li>
<li>In file qk_lock.cpp corrected a comment</li>
<li>In file <a class="el" href="qk__sched_8cpp.html" title="QK_schedule_() implementation.">qk_sched.cpp</a> corrected a comment</li>
<li>Provided "QS/C++ Programmer's Manual" in PDF.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> changed around the pre-defined records. Added records: QS_QF_INT_LOCK, QS_QF_INT_UNLOCK, QS_QF_ISR_ENTRY, QS_QF_ISR_EXIT. Removed records QS_QK_INT_LOCK, QS_QK_INT_UNLOCK, QS_QK_ISR_ENTRY, QS_QK_ISR_EXIT.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> renamed functions QS::filterIn()/ QS::filerOut() to <a class="el" href="class_q_s.html#ada98eb39016cd904a92bace92b1cd250" title="Turn the global Filter on for a given record type rec.">QS::filterOn()</a>/ QS::filerOff(). Correspondingly, changed macros QS_FILTER_IN(), QS_FILTER_OUT(), to <a class="el" href="qs_8h.html#ab1daab0f67adda321cd13b42c6042023" title="Global Filter ON for a given record type rec.">QS_FILTER_ON()</a>, <a class="el" href="qs_8h.html#ae3d7888f95ecf7b24005a618ebc0ef89" title="Global filter OFF for a given record type rec.">QS_FILTER_OFF()</a>.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> changed the signature and semantics of <a class="el" href="class_q_s.html#a739e53adeba745b9fe716adaea5d9517" title="Byte-oriented interface to the QS data buffer.">QS::getByte()</a> to return QS_EOD (End-Of-Data).</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> changed the signature of <a class="el" href="class_q_s.html#a5717cbabfdc548d5a1573a5286e1efe3" title="Block-oriented interface to the QS data buffer.">QS::getBlock()</a> to take a pointer to uint16_t rather than uint32_t.</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> eliminated the callback QS::newRecord()</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added new callback QS::flush()</li>
<li>In file <a class="el" href="qs_8h.html" title="QS/C++ platform-independent public interface. This header file must be included directly or indirectl...">qs.h</a> added application-level local filter object <a class="el" href="class_q_s.html#a75fa0811da83446630e303079929156c" title="generic object Application QF local filter">QS::apObj_</a>. Consistently, added macro <a class="el" href="qs_8h.html#aa6a82e6fda0dd1bb27a1ea0ca485a8a1" title="Local Filter for a generic application object obj_.">QS_FILTER_AP_OBJ()</a> to set the new local filter. Consistently, added object argument to macros <a class="el" href="qs_8h.html#ad99a023424e53db53e3a0bd6befe3f8e" title="Begin a user QS record with locking interrupts.">QS_BEGIN()</a> and <a class="el" href="qs_8h.html#a7c44cbd136e7a071918ff646ec997b17" title="Begin a QS user record without locking interrupts.">QS_BEGIN_NOLOCK()</a>.</li>
<li>In files <a class="el" href="qs_8cpp.html" title="QS internal variables definitions and core QS functions implementations.">qs.cpp</a>, <a class="el" href="qs___8cpp.html" title="QS functions for internal use inside QP components.">qs_.cpp</a>, <a class="el" href="qs__blk_8cpp.html" title="QS::getBlock() implementation.">qs_blk.cpp</a>, <a class="el" href="qs__byte_8cpp.html" title="QS::getByte() implementation.">qs_byte.cpp</a>, <a class="el" href="qs__pkg_8h.html" title="Internal (package scope) QS/C++ interface.">qs_pkg.h</a> renamed some variables and adjusted comments.</li>
<li>Ported the QSpy host applicatoin to Linux. Added TCP/IP input to QSpy. Added new options.</li>
<li>Added redesigned <a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a> port to Linux with TCP/IP data link.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_1_02"></a>
Version 3.1.02 (Product)</h2>
<p>Release date: Jan 29, 2006</p>
<ol type="1">
<li>Removed <a href="http://www.state-machine.com/products/">Quantum Spy</a> (<a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a>) dependency from the QCalc and QHsmTst examples</li>
<li>In file <a class="el" href="qk_8h.html" title="QK/C++ platform-independent public interface.">qk.h</a> removed callbacks QK::init(), QK::start(), QK::idle(), and QK::exit(), because they duplicate the <a class="el" href="class_q_f.html" title="QF services.">QF</a> callbacks.</li>
<li>Modified <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations.">qk.cpp</a> to define the following <a class="el" href="class_q_f.html" title="QF services.">QF</a> "callbacks": <a class="el" href="class_q_f.html#a8753eb3f87b739ddf49fd73357a762d1" title="Returns the QF-port version.">QF::getPortVersion()</a>, <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application.">QF::run()</a>, <a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework.">QActive::start()</a>, and QActive::stop_().</li>
<li>Added an argument to the signature of QK::schedLock() to allow selective <a class="el" href="class_q_k.html" title="QK services.">QK</a> scheduler locking up to the specified priority level.</li>
<li>Changed the implementation of QK::schedLock() in file qk_lock.cpp.</li>
<li>Eliminated the need for qf_port.cpp in the QF/C++ ports for <a class="el" href="class_q_k.html" title="QK services.">QK</a>.</li>
<li>Simplified elements that go into qk_port.cpp in the QK/C++ ports.</li>
<li>Added the ARM-Simulator port to the standard QK/C++ distribution.</li>
<li>Cleaned-up the 80x86 <a class="el" href="class_q_k.html" title="QK services.">QK</a> port.</li>
<li>Provided "QK/C++ Programmer's Manual" in PDF.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_1_01"></a>
Version 3.1.01 (Snapshot)</h2>
<p>Release date: Oct 18, 2005</p>
<ol type="1">
<li>Removed <a href="http://www.state-machine.com/products/">Quantum Spy</a> (<a class="el" href="class_q_s.html" title="Quantum Spy logging facilities.">QS</a>) dependency from the examples</li>
<li>Added Doxygen documentation to the source code</li>
<li>Added running__ member to the <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes.">QActive</a> structure</li>
<li>Added QF_EVENT_SIZ_SIZE configuration macro and related data type QEventSize. Made the following changes to the signatures: void <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events.">QF::poolInit(void *poolSto, uint32_t poolSize, QEventSize evtSize)</a>; <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> *QF::new_(QEventSize evtSize, QSignal sig);</li>
<li>In file <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a> changed the definition of the <a class="el" href="qmpool_8h.html#ac41e4f294d103c68521f9ad1f8e4e3b4" title="macro to override the default ::QMPoolSize size. Valid values 1, 2, or 4; default 2...">QF_MPOOL_SIZ_SIZE</a> macro to remove the dependency on the <a class="el" href="qf_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="Default value of the macro configurable value in qf_port.h.">QF_EVENT_SIZ_SIZE</a>. Macro <a class="el" href="qf_8h.html#a1272d49c23ca5852a7a8e9603ba32d31" title="Default value of the macro configurable value in qf_port.h.">QF_EVENT_SIZ_SIZE</a> might not be defined by the time <a class="el" href="qmpool_8h.html" title="platform-independent memory pool interface.">qmpool.h</a> is included.</li>
<li>Added explicit definition of the configuration macro QF_EVENT_SIZ_SIZE to all <a class="el" href="qf__port_8h.html" title="QF port to QK for a &quot;generic&quot; C++ compiler.">qf_port.h</a> files.</li>
<li>Fixed a bug in function <a class="el" href="class_q_m_pool.html#aa669322b615cf7d2e75a61396eca802e" title="Initializes the native QF event pool.">QMPool::init()</a> (file <a class="el" href="qmp__init_8cpp.html" title="QMPool::init() implementation.">qmp_init.cpp</a>) by changing the type of variable n from uint8_t to QMPoolCtr. The uint8_t data type was failing for bigger block sizes.</li>
<li>Added the QF::onIdle() callback to <a class="el" href="qf_8h.html" title="QF/C++ platform-independent public interface.">qf.h</a></li>
<li>Improved comments in <a class="el" href="qpset_8h.html" title="platform-independent priority sets of 8 or 64 elements.">qpset.h</a></li>
<li>Corrected dependencies in the Makefile for QDPP example (directory 80x86 and 80x86)</li>
<li>Added Linux <a class="el" href="class_q_f.html" title="QF services.">QF</a> port to the standard QF/C++ distribution.</li>
<li>Released the "QF/C++ Programmer's Manual"</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_1_00"></a>
Version 3.1.00 (Beta)</h2>
<p>Release date: Oct 03, 2005</p>
<ol type="1">
<li>Applied new directory structure desribed in <a href="http://www.state-machine.com/doc/AN_QP_Directory_Structure.pdf">Application Note: QP Directory Structure</a></li>
<li>Added <a href="http://www.state-machine.com/products/">Quantum Spy</a> instrumentation.</li>
<li>Removed file qfsm_tra.cpp.</li>
<li>Introduced file <a class="el" href="qfsm__dis_8cpp.html" title="QFsm::dispatch() implementation.">qfsm_dis.cpp</a>.</li>
<li>Applied new directory structure desribed in <a href="http://www.state-machine.com/doc/AN_QP_Directory_Structure.pdf">Application Note: QP Directory Structure</a></li>
<li>Added <a href="http://www.state-machine.com/products/">Quantum Spy</a> instrumentation.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_0_11"></a>
Version 3.0.11 (Beta)</h2>
<p>Release date: Aug 14, 2005</p>
<ol type="1">
<li>Fixed potential race condition for static transitions</li>
<li>Added assertion in QHsm::execTran() to catch potential path[] array overrun that previously could go undetected.</li>
</ol>
<h2><a class="anchor" id="qpcpp_3_0_10"></a>
Version 3.0.10 (Beta)</h2>
<p>Release date: Aug 06, 2005</p>
<p>This release contains completely redesigned Quantum Event Processor (<a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a>). The main focus is on compliance with standards (MISRA, Lint, Coding Standard), better portability, stack-use efficiency.</p>
<ol type="1">
<li>This release includes a comprehensive "QEP/C++ v3.0 Programmer's
Manual" in PDF.</li>
<li>This release contains in-source comments for automatic generation of this Reference Manual with <a href="http://www.doxygen.org">doxygen</a>.</li>
<li>This release includes re-packaging the code into much larger numberof modules (.cpp files) with typically one function per module. This fine-granularity packaging allows for better automatic elimination of unused code at link time and fine-tuning by applying different compiler options to different files.</li>
<li>Although this is a C++ version, it has been still thoroughly checked against the Motor Industry Software Reliability Association (MISRA) "Guidelines for the Use of the C Language in Vehicle Based Software", April 1998, ISBN 0-9524156-9-0 (see also <a href="http://www.misra.org.uk">http://www.misra.org.uk</a>). A separate Application Note "QEP/C++ MISRA Compliance Matrix" contains detailed account how QEP/C++ compiles with the 127 MISRA rules (See <a href="http://www.state-machine.com/doc/AN_QP_Cpp_MISRA.pdf">http://www.state-machine.com/doc/AN_QP_Cpp_MISRA.pdf</a>).</li>
<li>This release is now "lint-free". The source code has been thoroughly checked with the latest version of PC-lint(TM) (version 8.00q) from Gimpel Software (www.gimpel.com). The PC-lint configuration files and output files are included in the distribution. A separate Application Note "QEP/C++ PC-Lint Compliance" contains detailed account how QEP/C++ compiles with PC-Lint. (See <a href="http://www.state-machine.com/doc/AN_QP_Cpp_PC-Lint.pdf">http://www.state-machine.com/doc/AN_QP_Cpp_PC-Lint.pdf</a>).</li>
<li>This release is compliant with the "Quantum Leaps Coding Standard" (<a href="http://www.state-machine.com/resources/QL_coding_standard.pdf">http://www.state-machine.com/resources/QL_coding_standard.pdf</a>). Among others, all public names are prefixed by "Q_", or "QEP_" to minimize compile-time and link-time name conflicts. In addition, QEP/C++ uses the C99 standard include file &lt;stdint.h&gt; (C99 Standard, Section 7.18). Pre-standard compilers are still supported by placing &lt;stdint.h&gt; in the compiler's header file directory.</li>
<li>The <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> class has been redesigned to use memory more efficiently. <a class="el" href="struct_q_event.html" title="QEvent base class.">QEvent</a> takes up only 2 bytes now.</li>
<li>The <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> class now derives from the <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> class, which promotes better code re-use. In particular, macros Q_INIT() and <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> are now common for both traditional non-hierarchical FSMs and for HSMs.</li>
<li>The <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> class has been redesigned to allow using entry and exit actions. Now the <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a> class strictly avoids recursion, just as <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> does (MISRA rule 70).</li>
<li>The QPseudoState type has been eliminated and replaced by QState.</li>
<li>The central <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> class in <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> has been completely redesigned. The basic transition algorithm is essentially the same as described in "PSiCC", however the implementation is very different. The redesign was necessary to comply with the MISRA rules and to eliminate Lint warnings.</li>
<li>The event processor is now strictly non-recursive (MISRA rule 70), that is, event handlers never call themselves, even indirectly. (Previous algorithm required one-level of indirect recursion.)</li>
<li>Dynamic state transition is now default. Static transition optimization is still supported, but considered optional for performance tuning.</li>
<li>The artificial limitation of initial transitions targeting only immediate substate of a composite state has been removed (see "PSiCC" Figure 5.4[a]). Initial transitions can now target any substate, arbitrarily nested within the composite state.</li>
<li>This distribution uses the legacy Borland Turbo C++ 1.01 as the default compiler. Port to DOS with Turbo C++ 1.01 is provided along with GNU-compatible makefiles for the <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> library and sample applications. This compiler is not C99-compliant and does not provide the &lt;stdint.h&gt; header file. However, the port of <a class="el" href="class_q_e_p.html" title="Provides miscellaneous QEP services.">QEP</a> includes a minimal &lt;stdint.h&gt;, which should be placed into the INCLUDE directory of the Borland Turbo C++ 1.01 installation.</li>
<li>This distribution contains three sample applications: A simple time bomb (QBomb) to demonstrate use of <a class="el" href="class_q_fsm.html" title="Finite State Machine base class.">QFsm</a>, a calculator (QCalc), and an exhaustive test of the <a class="el" href="class_q_hsm.html" title="Hierarchical State Machine base class.">QHsm</a> class (QHsmTst). All examples are implemented as text-only application compiled with Turbo C++ 1.01. The QHsmTst sample application supports interactive and batch mode for exhaustive testing of the event processor. The source code for QHsmTst demonstrates also how QEP/C++ application code can be MISRA-compliant.</li>
<li>This distribution contains make files for the Turbo C++ 1.01 make utility, as well as GNU-compatible Makefiles. </li>
</ol>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jan 7 2011 21:37:31 for QP/C++ by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
